<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[今日畅想]]></title>
    <url>%2F2020%2F08%2F24%2F%E4%BB%8A%E6%97%A5%E7%95%85%E6%83%B3%2F</url>
    <content type="text"><![CDATA[hhh没什么好说的就是记录一下我自己的最近的思考。不过很多我都忘记了。我其实一直都没有注意到我自己的头发的问题。不过我身边的朋友倒是会有这种苦恼。前几天把我养了三个月的头发剪掉了，被姑姑带去一个贵宾理发店。打了三折剪了个屌头居然还要800多这我是压根就没有想到的（单位是人民币）。发型师说我脸型很好，五官很不错，不过这我不知道是不是真的，姑且可以当作是真的。不过他渐渐指出了一些问题，说我头上的发量不是很足。还是第一次有人说我的发量不是很足。高中的时候也是不喜欢剪头发，除非有人说什么，要不然就是一个多月或者两个月，那个时候剪头发的tony老师还会照例给我的头发打薄，现在我已经到了不需要打薄头发的地步了。 以前在想，为什么国民生产总值上去了，却感觉还是那么贫穷（泛大众）。后来我想到了，或许应该是国民生产总值代表的仅仅只是生产总值罢了。譬如某个汽车厂生产汽车平均下来需要一部车需要一个员工20天的工作量，成本是1w，但是车的售价是5w。可想而知成本+员工的薪资是远远没有汽车的售价高的。如果再算上其他一些成本譬如厂房，器械，管理，销售我也不知道怎么算。反正我自己的结论就是国民生产总值代表的仅仅只是生产总值罢了。 中国几乎在每一个有村支部的乡镇，不论这个乡镇有多么的山区，荒郊野岭。总能有一条公路能够通道乡村内部去。就是小小的一条公路的支线，可能生产的成本能够上百万。不过这个乡村或许只有几十户老人了，如此对于社会亏本的生意不一定是真的是100w，或者是国家自己建设出来的成果，或许需要真正投入的东西（水泥：xxx吨···，筑路工人薪资：xxx···）并没有那么多，但是成果确实是一条价值100w的水泥路。或者更加类似于日本东京的房地产泡沫。（1989年，日本的房地产价格已飙升到十分荒唐的程度。当时，国土面积相当于美国加利福尼亚州的日本，其地价市值总额竟相当于整个美国地价总额的4倍。） 好久好久没有综艺类型的东西了。我扪心自问这种东西贼无聊，这种几个明星的娱乐活动，感觉不如和兄弟打游戏来的确切而真实。 有人退给我看一篇杨笠的最近的脱口秀，我还没看什么内容，微博都是全员叫好，我寻思这也太离谱了吧。我看完后去知乎看看倒是感觉客观了些许。下面我做个复盘。 “对，我又来了。跟去年一样，我还是单身。就是我也单身太久了吧！我觉得自从做了这一行以后，对我的感情生活可以说是雪上加霜。就是我是真的不懂，我为什么会单身这么久。我觉得很多男生可能有点误会我了，他们就觉得我天天在台上讲段子，感觉很凶，好像很喜欢攻击男生，我是不是讨厌男生。没有恰恰相反，我是因为喜欢你们，才攻击你们的。真的我太喜欢你们了，我喜欢你们喜欢到我都不忍心贪恋爱。因为我没有办法在众多的你们当中选出一个。我会想说，像男人这么美好的东西竟然还要选？你知道那男人不光美好，还特别神秘，就是你永远也猜不透，他那小脑瓜力到底在想一些什么。就是他明明看上去那么普通，但是他却可以那么自信。就是你在这个台上看到很多，很奇形怪状的男演员，但是我跟你说，他们其中没有任何一个想过说，我这个长相，要是上电视的话，是不是得稍微整整容。没有的。我从小就很困惑，每个班都有那种女生，她学习成绩很好，她每次都能考85分以上，但她就是不开心，就是想为什么我没有考100分。但是那个男同学，他就能考40分，但是他可开心了，你感觉他拥有全世界，他拿着那张卷子在班里来回穿梭，好像在说，你看我就考40分，你看，我是个傻子。还有男生跟女朋友吵架的时候，他们特别爱说，你能不能不要这么无理取闹，你能不能理智一点。所以我每次都想说，大哥，所以你觉得他当年之所以选择你，跟你谈恋爱，是因为她比别人理智吗？而且谈恋爱为什么要是理智的，谈恋爱要是理智了跟单身有什么区别。她要是想理智，她要是想展示，她的逻辑思维能力和文化知识水平，她为什么去谈恋爱，她去工作就好了，她为什么要浪费时间跟你谈，她每天下班之后都跟自己经理谈一谈，说不定还能谈成副经理。所以我就特别不认同保持联系，保持距离这句话，我觉得真爱就是没有距离，没法保持你知道吗？就即便是交朋友，我们必须得全身心地付出，无条件的和彼此站在一起。你知道我这辈子说过最刻薄的话是对谁吗？就是对我闺蜜男朋友的前女友。就是这个女人，我不认识她，但是我恨她。就是我跟我的闺蜜们去聚会，我就看到她在刷一个女生的朋友圈，我就看了一眼。我说这是谁啊，长得真好看。她说这是我男朋友的前女友，我立马就改口说，一看就不是好东西。我说长得这么好看性格不可能好，性格决定命运，她命好不了。她叫什么名字，听说好像叫瑶瑶。我说叫瑶瑶的能有什么好人啊，可是另一个人说，可是我女朋友就叫瑶瑶。我说那对不起了，那今天必须得牺牲你女朋友了。今天我们对瑶瑶就是要赶尽杀绝。因为我们女生交起朋友来就是这样，没有理智的。但是你们试过和男生倾诉心事吗？我试过，有一次我失恋了，我就和一个男生朋友说，我说我失恋了他跟别人跑了。然后那个男生朋友跟我说，那也是没有办法。他说我一直觉得他很优秀，你有点配不上她。我是拿你当朋友才和你说的。他说，我说你别拿我当朋友了，你拿我当个人吧，一个有感情的人。我 就像为什么，为什么这些男的一定要这样。我后来想明白了，还是因为你们啊，特别自信。因为像我们女生，我们就知道，我们自己说的话不重要，没有人在意，除了朋友在意，没有人在意。所以朋友怎么开心，我们就怎么说。但你们男生不一样啊，你们是世界的主角啊，你们永远站在世界的中心，你们说的每一句话都特别的重要都是至理名言，都为这个世界指明了发展的方向，所以你们会想说，啊，这个人只是单纯的来找我倾诉心事的？不可能，他以当时想从我身上学到一些什么，然后，你们就会用自己的实际行动教给她们最重要的一个道理。那就是男的，都是垃圾（都是垃圾已消音）。” 没想到我折磨王有朝一日也会折磨我自己。整篇叙说我都寻思离谱。现场的人笑了也当真也就是了，当真那也无所谓，反正智商也不高。 从一开始开始，说自己又来了，单身太久了。不太明白自己为什么会单身这么久。这里我说一句话单身太久的根本原因永远都都可以归结于自己的问题，无非就几点。自己不想谈恋爱，自己想谈恋爱看不上别人或者别人看不上自己。别人（自己）看不上的无非就是认为自己有或者会有更好的目标。想要快速脱单也太简单了，随便去个经济发展落后的小乡村就是了，单身汉不要太多。不过她对于自己的解答是很多男生误会她了，说她攻击男生，不太喜欢男生（我她妈从来没有听过这个人的名字）。并且为自己解释（狡辩）我太喜欢男生了，喜欢才攻击。（离奇的解释没有给出什么叫喜欢才攻击纯粹可以理解为阴阳怪气）紧接着太喜欢你们了，我喜欢你们到没办法在众多的你们选一个。这里可以看出是她自己要选，但是下面却反问自己男生这么美好的东西还要选（前后狗屁不通也是阴阳怪气）。“像男人这么美好的东西竟然还要选”但是却没有继续论证男生美好，反而下面说男生神秘，猜不透，事实想说的确实“就是他明明看上去那么普通，但是他却可以那么自信。”欲抑先扬罢了。总的来说就是说了一通屁话，得出自己的看法男人不光不美好，甚至很恶心，看上去普通，确实自信。下面有了论证。 “就是你在这个台上看到很多，很奇形怪状的男演员，但是我跟你说，他们其中没有任何一个想过说，我这个长相，要是上电视的话，是不是得稍微整整容。没有的。”我一直都搞不懂为什么上台需要颜值，我认为清爽干净等就是了，我会对后天自己可以正面改变而不去改变的行为而唾弃，也会对无法改变事物的平静。固然可以说长得好看的更可能走红，但是在权衡利弊之下，男性更少的选择整容。这里我有自己独特的思考。向来都是所谓的男才女貌。其实才的获取太难了，貌的获取相对于的容易。并且男走貌的难度要大于女走貌。目前的社会提供了女性所谓的貌这条捷径也便甚至有了这般离谱的言论。她所认为的男性过于自信，我的理解是女的只想躺着赚钱罢了，有了困难先想着把自己物化，而所谓的奇形怪状的男演员就是像站着，还把钱给赚了，就此而言，高下立判。 “我从小就很困惑，每个班都有那种女生，她学习成绩很好，她每次都能考85分以上，但她就是不开心，就是想为什么我没有考100分。但是那个男同学，他就能考40分，但是他可开心了，你感觉他拥有全世界，他拿着那张卷子在班里来回穿梭，好像在说，你看我就考40分，你看，我是个傻子。”在我看来这是一个个例像代替集体的例子。不过我相信大多数是这样子的。对于这点论据的这点我不与反驳，但是突出了一个夸张的成分。班上所谓的女生85分以上，就是不开心。我认为是极其正常的，因为小学的话数学95分以上可以开心，语文90分以上可以开心。85分的数学而言确实不是一个好成绩，换做是我，我也会不高兴。而且这种学习的事情小学女生普遍都比男生好（包括初中，高中）。我认为是女性的个性的问题，在读书的时候，你只需要知道读书好是对的，就可以一直做这个漫无边际的事情。同样的女人比男人更加喜欢逛街，同样也是逛越多的街，看了越多的衣服，样本数目高了选择其中的一个说不定才是自己最喜欢的。而逛街的事情是单调也重复。所有接受过现代文明的人都会认为男性和女性的智力并无差别，但是擅长领域各不相同，男性的空间逻辑思维能力更强，女性的精密计算能力更强。而目前教育的（尤其是小学）从成绩分布来看，女生更加占便宜。所以我甚至有权利怀疑这样子的教育并不公平。其次考虑到她说男的40分，很高兴。事实上有了夸张的成分，这种春秋笔法的夸张令人反胃。可以是一个从来英语都没有上过40一直在20游走的男生考了40，可以是一直都能考80的男生突然考了40对于自己的自嘲。不论做了什么动作也好，就是当成是哗众取宠也罢，但是本质都是没有任何恶意的。所以为什么要解析为“你看，我是个傻子。”我时至如今依然没有搞懂对于一个小孩子出于另类的幽默而抱以如此的恶意以至于我认为前文所谓的太喜欢男生无非就是作秀的一纸空文。 “还有男生跟女朋友吵架的时候，他们特别爱说，你能不能不要这么无理取闹，你能不能理智一点。所以我每次都想说，大哥，所以你觉得他当年之所以选择你，跟你谈恋爱，是因为她比别人理智吗？而且谈恋爱为什么要是理智的，谈恋爱要是理智了跟单身有什么区别。她要是想理智，她要是想展示，她的逻辑思维能力和文化知识水平，她为什么去谈恋爱，她去工作就好了，她为什么要浪费时间跟你谈，她每天下班之后都跟自己经理谈一谈，说不定还能谈成副经理。”事实上，所有的吵架，每个人都想无理取闹，真正寻求解决矛盾以积极姿态面对吵架的才是理智的，不想解决问题，自顾自发脾气的，我认为是傻子。这点说明杨某的三观问题极大。下面对于这样的甚至还能加以论证。“跟你谈恋爱，是因为她比别人理智吗？”原作者的意思我可以理解为“你是个垃圾，我瞎了眼才跟了你”，言下之意就是男的配不上女的，吵架吵得正好早点分手对女生好，无非就是咪蒙套路女生洗脑罢了。谈恋爱一定要是理智的，要不然我38岁在职已婚男士发现了我的真爱20岁女大学生，是不是也可以正当地说这是真爱，和自己的老婆离婚？不显示的事情，所谓的真爱不过是见色起意罢了，若是真的真爱，那以前结婚的时候不是吗，我认为爱情不能逾越社会的规范。这种真爱早点散了就是了，对谁都好。就算不提这个女生的父母怎么看待的，就是同学知道了也不好；对于男人而言，自己的家室怎能就不管不顾。谈恋爱的理智太重要了。不知道最后的副经理指的是成为了经理的女朋友还是因为多谈了让领导发现自己的才能所在，或者甚至是某种方法混上去了（有可以这么怀疑的说法，没给出缘由，但是又引导人思考的成分）。 “所以我就特别不认同保持联系，保持距离这句话，我觉得真爱就是没有距离，没法保持你知道吗？就即便是交朋友，我们必须得全身心地付出，无条件的和彼此站在一起。”我就觉得这个所以离谱，前言不搭后语。不过姑且默认他要换一个论点叙述。 “你知道我这辈子说过最刻薄的话是对谁吗？就是对我闺蜜男朋友的前女友。就是这个女人，我不认识她，但是我恨她。就是我跟我的闺蜜们去聚会，我就看到她在刷一个女生的朋友圈，我就看了一眼。我说这是谁啊，长得真好看。她说这是我男朋友的前女友，我立马就改口说，一看就不是好东西。我说长得这么好看性格不可能好，性格决定命运，她命好不了。她叫什么名字，听说好像叫瑶瑶。我说叫瑶瑶的能有什么好人啊，可是另一个人说，可是我女朋友就叫瑶瑶。我说那对不起了，那今天必须得牺牲你女朋友了。今天我们对瑶瑶就是要赶尽杀绝。因为我们女生交起朋友来就是这样，没有理智的。”我认为如果是真的美，那没必要吝啬自己的赞美，所谓的“我说长得这么好看性格不可能好，性格决定命运，她命好不了。”是不是可以理解为女子无才便是德？很明显错误的论断，或者是作为安慰闺蜜的话也罢不过不应该拿到台前来说。在下面某个男生的女朋友叫做瑶瑶所以就是一起出来的朋友里就女性朋友有人权？这么多的女生都叫做瑶瑶凭什么要被你唾骂？这里我甚至可以怀疑他仇男。与一开始所谓的喜欢男生明显不符，不过是阴阳怪气罢了。不过对于自己认为的女生交起朋友来没有理智甚至有点沾沾自喜的成分在，这个人的脑子什么水平就不用我多说了吧。 “但是你们试过和男生倾诉心事吗？我试过，有一次我失恋了，我就和一个男生朋友说，我说我失恋了他跟别人跑了。然后那个男生朋友跟我说，那也是没有办法。他说我一直觉得他很优秀，你有点配不上她。我是拿你当朋友才和你说的。他说，我说你别拿我当朋友了，你拿我当个人吧，一个有感情的人。”典型的以偏概全，我甚至可以如法炮制给你说出为什么读大专要比读本科211，985要好。隔壁张家的女儿985读了个生物结果毕业找不到工作从事金融类了，我亲戚毛家的儿子大专读了个大专的车床收入高多了。所以读985不如大专？？？亦或者你想调查一些敏感问题。去问了一个你的同学，如果有一天真的可以男性帮女性怀孕了，你愿意吗？他回答不愿意。我甚至不知道假设这么问的目的是什么，论证男人自己也怕怀孕？我自己问了一个男生他说愿意呢？也没有可能，我甚至告诉你不光可能，而且是确切。我认为失恋了，找男生倾诉，是我的话，我第一反应会是我能为你做些什么吗？我一个朋友失恋了，我可以陪他在网吧打通宵？而且所说的“也是没有办法的”，无非就是自己的男朋友和自己一类人呗，你看不上别人，好不容易找到看得上了的，别人又看不上你。你要一个家里亲戚一大堆，全家收入只有夫妻的月薪6k的去和一个家产几十亿的人，想想也不是没有可能（真爱除外），其余的都是瞎扯淡。 “我 就像为什么，为什么这些男的一定要这样。我后来想明白了，还是因为你们啊，特别自信。因为像我们女生，我们就知道，我们自己说的话不重要，没有人在意，除了朋友在意，没有人在意。所以朋友怎么开心，我们就怎么说。”事实上男生永远没有女生自信，一个广西的厂妹在厂里有了几只舔狗就认为阿里的p8配不上。不论男生对于自己才貌有多像陈冠希，彭于晏，李易峰。那究竟是男追女多还是女追男的多，究竟是女生看不上男生多还是男生看不上女的多。如果说男生的话人人在意，女生的话没人在意，那么所谓的人人是包括男和女吗？那其中的女为什么要去在意呢？ “但你们男生不一样啊，你们是世界的主角啊，你们永远站在世界的中心，你们说的每一句话都特别的重要都是至理名言，都为这个世界指明了发展的方向，所以你们会想说，啊，这个人只是单纯的来找我倾诉心事的？不可能，他以当时想从我身上学到一些什么，然后，你们就会用自己的实际行动教给她们最重要的一个道理。那就是男的，都是垃圾（都是垃圾已消音）。”这个真的无力吐槽了，去写修真小说吧。自己虚构的东西还能得出看似自暴自弃，实则反讽男人的话我是真的觉得离谱。 这也难怪为什么微博这么多人说这个了。确实符合女生无理的行径，拿捏的死死的。 先睡个觉，最近很喜欢一个姐姐便是。]]></content>
  </entry>
  <entry>
    <title><![CDATA[打拳2]]></title>
    <url>%2F2020%2F06%2F01%2F%E6%89%93%E6%8B%B32%2F</url>
    <content type="text"><![CDATA[大部分男性在两性关系中常处于弱势的根本原因源于信息的不对等在两性关系中，如果把异性缘由好到差分为10个等级，10分最好，1分最差的话，那么你们可以发现女性的异性缘1-10分的人数分布会呈现出的是一个金字塔形状。但是换成男性的话，则是两头大，中间小的形状。也就是说1-2分和9-10分的人最多，中间3-8分的人极少甚至成真空状态。说大白话就是旱的旱死涝的涝死。 而让这种现象出现的根本原因就是绝大数男人在两性关系中对于女性的了解几乎没有。只有极少部分的男人真正的了解女性。这是男人与男人之间的信息不对等。俗话说“男人不坏，女人不爱”其实真正的意思不是女人都喜欢坏坏的男人，而是坏男人才真正懂女人。他们动了脑子，用女性的思维模式去思考问题，把她们像文件一样整整齐齐的归类，理性的去看待每一个女性。真正的把女性当成是一个人，而不是一个神去对待。所以他们才有了做渣男资格。 还有一种信息不对等是男人与女人之间的信息不对等。女人在成长的过程中，因为男女生理的差异性，大白话也就是男人好色，即便是女人自己不愿意去主动接触异性，她们也能够遇到各种形形色色的男人。所以，她们对男人早就有了一个比较清醒的认知。知道男人并不是每一个都像影视剧里的正派那样或温文尔雅，或坚韧勇敢。也有不少男人弱懦无能，胆小怕事。尽管女人可能在很多事情上被情绪所左右比较感性，但唯独在男人这事上相当的理性，把他们像文件一样整整齐齐的归类，物尽其用。反过来男人就差了很多，因为在男人的成长过程中，能和异性保持较多接触的男性是少之又少，可能很多男性到大学毕业都没好好谈过一次恋爱。这就导致了他们对同龄女性的了解全是靠电视剧输出。认为女性个个玲珑可爱，易受伤害。至今估计不少男性都还认为“脏乱差”的房间只可能是男人的房间。而实际上，能够有资格在感情上伤害女性的男人连10%都未必能到。 苏享茂的悲剧就是当代男性在两性关系中对女性缺乏认知的折射。他以为自己事业成功了有钱了，就能够得到如花美眷的芳心，从此迎娶白富美走向人生的巅峰。他从未想过一个女人能坏到把他逼上绝路连命都没了的地步。换成是一个男骗子，哪怕等级比翟欣欣再高上俩个等级都未必能骗死苏享茂。在他的认知里，也是大多数男性的认知里，所谓的渣女再坏又能坏到哪去呢？ 不外乎就是养个备胎，出个轨，拜个金。即便如此，在这些男人始终认为女人养备胎也好，出轨也好，拜金也好也是我们男的没本事，要是我们事业成功了就一定能找个秀外慧中的姑娘。而且他们还很天真的喜欢以貌取人，觉得渣女永远是那种穿着暴露浓妆艳抹的女人。而翟欣欣那样的姑娘肯定是谈吐优雅，有才有德，称人心意，惹人怜爱。正因为苏享茂的对女人的无知导致完全的不设防，所以当暴风雨来临时，渣女飞龙骑脸他才束手无才只能选择最愚蠢的办法也就是自杀。但凡是对女性有所了解，在两性关系中有点阅历，即使一时鬼迷心窍，遇事也不至于落得如此凄惨的下场。我敢断言，很大一部分男性要么事业别成功，一旦成功大概率又是下一个苏享茂。 综上所述，这也解释了为什么知乎答主邹禹同会被女权围攻。因为女性在两性关系中的巨大优势就是因为信息的不对等。而邹禹同所做的事就是在给男性传达信息，告诉男性这个世界上有很多渣女会骗光你的一切，然后和另一个男人住大房子过舒服的日子。而你只能在小隔间里孤独终老。其实女权根本不是怕邹禹同普法，因为即便是男人知道加了名字房子会被分掉，女权也有一百种办法让男人加上名字。因为男人根本就不知道这个世界的部分女人有多坏，以为个个姑娘都是需要呵护的“易碎品”。女权真正怕的是邹禹同在关于财产保护的普法过程中，难免会举出无数的案例让男性都看到部分女人的丑恶面从而改变信息不对等的局面。男人不是不知道怎么防备，而是根本没有想过要去防备一个“弱女子”。战争片里，很多身经百战的一流特种兵不都死在那些看似无害的人手里。不信你可以尝试在网络社区分别发表一些内容，你会发现一个很有意思的事情，就是你发一些直白的歧视女性的言论受关注的程度有时候还没有你曝光一些女生寝室脏乱差大。前者你只会被女权当成笑话挂出来调侃，而后者才是真正踩到她们的尾巴。她们会说：人家寝室怎么样关你屁事？你也不看看你们男人自己的寝室有多脏多臭。她们不是因为寝室的脏乱差而羞愧导致恼怒，而是你的宣传有可能导致女性在大部分男性心目中的“神性”被消弱。还是那句话，她们害怕失去信息不对等的优势。女权费尽心机的维护那些渣女，给她们找理由找借口，说白了就是想维持女性人畜无害的印象，让男人放松警惕卸下防备她们才有机可乘。]]></content>
      <tags>
        <tag>打拳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打拳1]]></title>
    <url>%2F2020%2F06%2F01%2F%E6%89%93%E6%8B%B31%2F</url>
    <content type="text"><![CDATA[请大家听我缩刚刚刷知乎看到一个问题：你有什么想对知乎反女权说的话么？突然有了一些不成熟的想法想说给大家听听。我们反女权一直采取的都是隔空喊话输出观点为主，正面对线为辅的舆论战模式。虽然舆论战是必须的，但我们似乎选错了方向。我个人有点不成熟的建议想分享一下，说的不对可以指正。文字有点长。 首先，我觉得我们必须努力向支持者们传达出一个核心理念让他们明白：并非先有女权，才诞生了女权主义者。而是本就有大量女权主义者的存在，为迎合市场才有了女权。咪蒙的出现也是这个道理，是有人需要咪蒙才有了咪蒙。这个概念是我们所有舆论的基础。要让大家清楚的知道从来就没有人被洗脑，而是这帮人本来就很坏。然后资本知道无产队伍里有大量这样的坏人存在，才用上女权把它们归拢收集到了一起。女权只是一把刀，而让这把刀伤害别人的是女权主义者。这就好比你开饭馆，选门面的时候最优先预判的不就是这个位置大量人流中有吃饭需求的潜在人群有多少？这么做的目的就是为了让部分虽然心中反感女权但任对女权主义者抱有幻想认为它们只是一时糊涂被洗脑的人抛弃幻想彻底死心和清醒，明白人性本恶男女都一样的道理。即便没有女权那些女权受众也是存在的，也会在现实中剥削无产的价值和奴役无产者的思想。所以与对方大V辩论没有作用，侥幸搬倒一个立刻就会冒出来下一个接手蛋糕。指望辩论胜利后女权主义者就会消失的想法不切实际，更何况打倒女权本来也不可能。你反驳它们的理论，它们立刻就能再造一个理论反驳你，甚至我们很多的论据在我看来还是靠女权故意送的菜。这种反复复读的消耗战我们打不起，因为我们完全无法和它们完整的利益链所抗衡。 只有成功传达好上述理念的基础上我们才有可能拥有属于我们自己的正确的统一的完整的理论体系并且实践化然后形成足够博弈的规模。跟它们辩论纯属浪费口舌，你以为你只是在和一个或几个女权辩论，其实你对抗的是对面整个舆论体系。其实城市猎人的理论体系一直都是正确的，难就难在非常难以实践。恕我直言，好多人对于他的观点都停留在：恩，大神说的对，大神说的好。然后关了知乎现实该干嘛还是干嘛，所有的一切都抛之脑后了，刚刚城市猎人说了些啥他百分百忘了个八九。即使少数人吃透了城市猎人的理念，但正如我上边第二段所说的任然对某部分人心存幻想，担忧自己伤害到别人，却不知道它们伤害我们的时候从来没有手软过。对面已经不要下限了，我们这里居然还有人心存怜悯怕伤害柔弱的它们。我说句你们不爱听的，大家好好照照镜子也包括我自己，就咱们这些工具人有啥资格当施暴者伤害到别人？每100年能有一台ATM自爆算是多的了。这就好比我们手上明明就有枪，却不知道如何使用或者不愿意去使用。内部不团结分歧较大，这就是舆论战我们永远处于下风，反女权收效甚微的真正原因。 最近知乎邹禹同被女权线下线上同时围攻让我感触颇多。他的普法歪打正着爆击了某些人的痛点。这些人并非害怕别人懂法后影响它们骗钱，而是害怕邹博的普法让许多人看清了原来贪婪是不分性别的。女性是可以通过合法手段让男性受到重创的。部分女性的弱和需要安全感只是一层伪装。对于两性关系中信息不对等的局面会有所改观，让那些对女性的认知仅仅只靠影视作品的男性开始对女性有了新的认识，加深坏人不分性别的印象，对女性的信任感降低到一个理性的点。女权或者说渣女们真正害怕的是无产者们认知的转变，对女性不捧不踩，用对待同性的方式一视同仁的对待女性。开始不再轻易相信女权者在现实中说的话，开始怀疑它们观点和动机，开始警惕它们的作为，开始对女性理性和戒备，开始面对女性也有了自我保护意识。 所以，我个人倡议，希望各位反女权和支持者们：希望大家一起放下轻视不屑，放下傲慢，放下争强好胜的潜意识，学习我们对立面的团结，在保持自己原有答题风格的同时，能够在自己的回答和文章中适时的加入人性本恶，男女一样，女权主义者本来就坏，而非变坏的核心理念。通过普法法律是最好的武器，还有将城市猎人等大V有整套理论体系的观点拓展和修改的更加通俗易懂具有实操性然后传播出去，同时学习女权故意曝光大量男性作恶让女性因为恐惧而加入它们的办法大量披露现实中部分女性的负面让大家能够真正看清现实。比如去知乎提问：你见过最邋遢女生宿舍有多脏？这类问题绝对能让女权跳脚，它们最害怕的就是男女互相认知信息不对等的僵局被打破，失去原本披着的美好外衣，这也是邹禹同被骂的那么惨的真正原因。改变散乱游击以个体对抗对面整个舆论体系的局面，形成体系对体系才有可能迎来一丝曙光。我们真正的敌人不是女权大V，而是它们的粉丝。]]></content>
      <tags>
        <tag>打拳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[芜湖]]></title>
    <url>%2F2020%2F05%2F27%2F%E8%8A%9C%E6%B9%96%2F</url>
    <content type="text"><![CDATA[@整夜辗转反侧事实上我见到的人都还是挺和善的，生活中并没有我视野范围内的女拳。或者就如同去街边的三轮车、地上的麻布袋所构成的流通摊点购买蔬菜一样。我今天想吃的是香菇，理所应当的我不会关注临近周围并没有香菇的摊点上的茄子的价格。基本上大家都还是很正常的，没必要把过多的不合理的网络虚拟的情绪带给周围的人。但是恶心的事是，那些洗脑、无耻鸡汤、无耻资本家的无良讯息还是会潜移默化的改变你在生活中对异性的认知。不论是什么样的男女，就算是铁了心的认为这是虚假的，或者是不正确的。但是和异性接触的时候，总还是会有念头闪过，或者一直有这种想法————“要是他（她）能那样就好了”。潜移默化的带来期待，一旦并没有开始有所谓的期许值，那么在以往的时间后，或许都不知道自己的心里已经默认会有他（她）已经欠你的了。]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[俞敏洪]]></title>
    <url>%2F2020%2F05%2F26%2F%E4%BF%9E%E6%95%8F%E6%B4%AA%2F</url>
    <content type="text"><![CDATA[俞敏洪语录方向决定了教育的方向，而不是说，写了一本书，写了一个核心素养，大家去读就能改变教育的方向的。举个简单例子，一个女生，如果中国所有女生找男人的标准，都是这个男人必须会背唐诗宋词，那全中国所有的男人，都会把唐诗宋词背得滚瓜烂熟。如果说所有的女生都说中国男人，就是要他赚钱，至于说他良心好不好我不管，那所有的中国男人都会变的良心不好，但是赚钱很多的男人。这就是现在中国女生的挑选男人的标准。所以实际上一个国家到底好不好，我们常常说在女性就是因为这个原因。现在中国是因为女性的堕落导致了整个国家的堕落。]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从卸载虎扑说起]]></title>
    <url>%2F2020%2F05%2F09%2F%E4%BB%8E%E5%8D%B8%E8%BD%BD%E8%99%8E%E6%89%91%E8%AF%B4%E8%B5%B7%2F</url>
    <content type="text"><![CDATA[给个链接，刚刚发的一个帖子女朋友是大二前端开发者，准备选购macbook pro求jrs推荐. 永久不删除 我真的就是觉得很普普通通的一个文章，结果被我自吴亦凡和虎扑因《新说唱》的互怼而加入jrs的阵营以来，对虎扑感觉有着前所未有的失望。一个个人都不知道算成什么样子。虽然说是直男的论坛一起玩玩发发帖子都还挺好。也会有一些莫名其妙的抖机灵。和以前的贴吧/天涯论坛一样，会有很多精品的帖子出现。但是总的学历水平估计还是挺低的。就目前看来可能平均学历并没有多高。我也参与过投票，某种月经帖，jrs的学历。密密麻麻，从小学开始，初中······一直到院士。投票总是院士最多，也就随随便便打趣便是了。 但是我发的帖子确实没想到，就老老实实问一个什么电脑好。 真的离谱，为了咨询一个合适的电脑就还要把自己的github仓库搬出来说这是我自己的仓库你们去看吧？就前后端都可能没搞清楚是什么意思在质疑一些莫名其妙的东西。 我就搞了这么一个回复：“我来统一回复一下。 目的就只是为了咨询一下电脑。我觉得i5，8代也不是不能打一般都够用了，但是这东西肯定越新越好。但是内存还是16g好一点。我自己8g，譬如跑一个idea，外加一个浏览器，开两个qq内存就满了。 至于前端开不开发原则上来说和大二没什么关系。主要是说自己的收入不是很高，最多最多也就是靠着赚外快，接点外包赚点小钱，也都高兴。那至于好奇的是不是还要github仓库给你们康康。我不知道我女朋友写的怎么样。反正我自己的后台管理少用了很多技术，要学的太多了。但是至少就springboot+mysql能跑得通玩得成任务倒是可以保证。不会有人真的以为就算是计算机专业靠着学校这些就够给你找到步行街街薪了8⃣️？总得慢慢学习的嘛。 学校的一些计算机网络，数据结构这些挺好，但是不一定教你spring全家桶这些。总得还是要靠自己自学的。就是你不自学，就是你毕业当了个程序员了，还不是几年后被裁。 总而言之就是，称呼什么样的无所谓你觉得是就是，你觉得不是就不是。反正我觉得是，这个帖子的目的只是为了讨论决赛圈的电脑那个更加契合。她说想省点钱，我说还是冲16g内存的好。屏幕也问过了16寸不是刚需，用不到这么大的，反而还会感觉有点大，不太方便。id是重庆邮电大学仙居招生办的说掌握这么这么多。我寻思我和你可能还是校友，如果你家在仙居我和你都还是老乡。我寻思这前端也用不到数据库吧。就算是如此，那也不是一年，大二了，都快升大三了，按照课程来你说的也都差不多。 id是唠嗑创造纸巾王朝的：这个大基础应该是Java基础吧。你可能花的时间少罢了，或者你可以考虑考虑换一个方向学习。 id：就是为了试试改名。讲道理，你是最酸的 id：至爱戴维斯。我觉得吧你打lol开120帧和30帧就是不一样。能够在自己承受的范围内舒服一点为什么不好呢？你以前两三千的也可以是没问题。你更加量入为出，我感觉我比较量入为出罢了。 此后的帖子应该不回复了。” 那还就叫一个脾气好。真的酸到根部。网上太容易吵架了。 前天想着打lol老老实实上一波分，结果一个下午到网上，三把彻彻底底队友吵起来。有一把一级团送了两个头，二级中单被对面两把长剑的男刀单杀，男刀二级的伤害是真的看不懂。但是我寻思也不应该为了这几个兵就硬着头铁。后来上单被对面打野抓死，我们打野也死了。打野就挂机了。其实并不是不能打，我自己的下路也算均是。但是打野就这么挂机了。说了句：“你们自己玩吧，再见。”想必这种人在哪里都是失意的吧。没有责任心的人，能是什么好东西。就算要退，譬如15分钟的时候建议投降，必输的局没必要折磨了诸如此类的。但是自己四分钟挂机原本可能赢的就不可能了。真的低等人。 低等人见得多了我这里想到什么骂什么。 说什么逢年过节男人送女人什么。我始终认为送东西属于情分而不是本分，不管是男女朋友还是夫妻。根据价值观的不同会有不同体现。譬如女人认为就应该送，结果男人没送。就算女人没有说出来。但是心里的失望还是会积攒的。但是为什么要积攒？从来就不应该有这种一味的自以为是的索取。我寻思这种观念就是恶心的资本家做的。所有的美好的节日只要被冠以购物街就会变得恶臭（没有例外，不会有例外）。譬如之前的三八国际劳动妇女节，硬要说什么女王节，女神节。这就离谱的一批。无非就是看着女人容易花钱呗。其实男人女人都很容易花钱，不一样的就是，想要骗到男人的钱比骗到女人的钱要难多了。 都说出去玩AA啊什么的。在我看来理应经济能力分配。一方高收入，一方低收入。高收入可适当分担一部分低收入的开销（关系好的话）。关系差的就别出来玩了，就同凉面。别拌了，真不熟。但是在社会地位上来说，男方应该承担大头或者全部的费用。确实在这个社会上男人的确实要比女人强势，女人所受到的不公要多余男人所受到的不公。但是如果想要做到男女平等就要在基础之消除这一偏见。指的就是男女理应AA。要真正的声明女权绝不应该是自己安然自若吃尽便宜。该花多少的就该花多少，花不起就别出来玩。但凡是想着白吃白喝的总是会低人一等。 就极端一点来说，拿着被包养的钱，谈什么独立人格，谈什么人生理想，我就觉得这也太奇怪了。逢年过节是应该，也是可以准备准备什么惊喜礼物什么的。但是那也得靠一个人的经济条件来说的。譬如就大学男女谈恋爱。过个圣诞节，两个人都是普普通通的1500零花钱过日子的人。女方突然提出要求说要原价1000rmb，现价只要800rmb的神仙水。这就很离谱了，这种垃圾还是趁早被中年大叔包养来的实在。可以做到的譬如请吃饭什么的。总得想想实际的，真实的。不是每个人都是bilibili《后浪》里的人物。没有上一辈的资本，靠着自己白手起家。玩电竞，手办模型。玩出点名堂确实不是一件容易的事情。搞这种还不如去买个彩票还容易中奖一点。兴趣归兴趣，若要是作为职业还得要三思。 先前说到了为什么总是想着女人购物，因为女人的钱太好骗了。而受苦的是给那些女人钱的男人或者但但是那些女人自己的钱包。我几个星期前和我姐姐碰了次面。他说下个月买一个xbox还是ps4的。我对这个兴趣倒不是很大。我说你不打算存钱结婚吗？她说结婚我需要花钱吗？确实是这么一个道理。可以不花钱，女方父母只负责拿彩礼，女方只负责貌美如花，拎包入住。这也有着的活法罢了。但是想要自己过得舒服，那势必要自己也该承担点责任。最浅显的就是，老了就不是貌美如花。不要总是想着自己吃一些看似是便宜的事情。人格上的低劣可不是说说就能挽回的。但凡自己把自己物化了，精神世界只会更加空虚罢了。 微博倒是有很多女权的事情。我是真的没有这么多的时间，没有这么多的经历去纠结这种事情。同理，新浪微博也是个罪魁祸首，就是这些无量平台使得当代中国乌烟瘴气。那些下班在家里洗衣服被下班后在外面喝酒回家耍酒疯的男人欺负的女人才不会高强度微博在线。那些女权微博究竟要diss的是什么东西我至今都没搞清楚。或者说就是想什么时候才可以仅她们所想。恰好想买双椰子350的时候出来一张椰子350券，且仅本人本次可用。 女拳们总是想方设法将自己化生为正义的都是，其实这也是叫不醒装睡的人。可能自己赚了一大波钱罢了，顺带声明一下自己的人类灭绝计划。总是借着小事情絮絮叨叨。就好似你去和一个小面馆的老板说其实读书很有用的。小面馆的老板说自己小学文凭，一年收入15w，自己儿子本科毕业只能找到3k一个月的工作。然后他又想到了，隔壁张大婶家的儿子，高中读的是职高，学了一手数控车床，现在一年能赚其10多w，李大娘家的女儿，无心读书，给他买到了某个大专，一年学费2.5w，结果出来找不到工作。总是想借着个别案例去驳斥基本事实。 一般来说本科毕业的平均月薪就是比专科的高，专科的更比小学毕业的高。只是个别不一样罢了。 女拳也会有反对结婚，恶心男人。其实从平等的角度来说，男人也不一定喜欢结婚，结婚也同样是男人的枷锁，所有套在女人身上的词几乎都可以套给男人。 总是念念不忘的子宫。那小孩子女人不生难道还男人生？要么你找个人做丁克算了。 总是念念不忘冠姓权。其实我觉得姓，理应跟着男方姓，先不说向往的西方资本主义的Mrs.是什么意思。我觉得这原本应该是作为缓解社会矛盾的基本准则。如果达成社会的默认事实也无不可，就不至于总是争吵。但是个别案例个别讨论。譬如女方是独生子女，男方有一个弟弟的情况还是从情分来说应该和女方姓。并不是女拳不女拳的问题，应该是男人厕所有专门尿尿地方女人没有的事情，司空见惯的罢了。 一个人要是渴望幸福就得先有幸福的资本。我还要批评恶心的抖音/快手里面买丑的。譬如做一些傻逼发明的，譬如就砸冰发出恶心笑声的，再例如在虎牙开直播的药水哥，以及阿giao。都是最最垃圾的，要说最有文化的还是药水哥。但是这个人的吃相是真的差。 如果都是说对眼的话就是正确的话，那还会有几个人会坚持捍卫人的尊严不写了，本文完。]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[准备考研了]]></title>
    <url>%2F2020%2F05%2F08%2F%E5%87%86%E5%A4%87%E8%80%83%E7%A0%94%E4%BA%86%2F</url>
    <content type="text"><![CDATA[嗯嗯，确实准备考研了如题之前断更了，很长时间。打算接下来的一些时间给自己的博客完善一下。都是很多的大佬提供的方法，我们只是使用它，又不是什么难事。 本文只是说我准备考研了。断更也并不是说我不是在读书，再摸鱼啊什么的。其实只是没有记录而已。 做了两个项目，感觉自己学的太少了。 姚秋鸿总是说我别想着他，他学的少。其实还不是比我多。我对自己没什么信心。都说就业难我也知道，但是工作室总是有人才出现，讲真的人才不管在哪里都是人才。譬如隔壁工作室的哪个浙江人，一看就是兢兢业业学技术的料。也没什么七情六欲。那个人在我寝室对面，他们同寝室的称之为电竞荒漠。但是其实人家肚子里东西是个海洋。 邓思远要我考虑学技术是不是应该继续学下去。确实我有懒，我也不知道为什么总是做不出来东西。我也不会去怪别人。自己的事情还是得自己说了算的。我也并不是说Java不行了。我只是觉得我的Java前途不太光明。我也不会去和别人比。别人学Java出来毕业年薪25w，而我只有15w。其实我现在目标15w就可以了，我也没什么大梦想。但是我觉得这条路子有点行不太通。现在学习编程的人太多了，回头出去还是搬砖。也许和搬砖工差别就在于，更加体面了。永远都需要不断的学习，而且依个人能力以及努力程度决定会不会中年被开除。累死累活还是这一条路罢了。 既然都是依照个人才能为祖国的建设奉献，那这么多人抢着这一条路奉献，我又能怎么样呢？ 我本是想一个契机，一个跳板选了学校并不选专业。但是既然没有成功转专业，那我的本科只能是电子商务了。论计算机，不如继续在工作上共同努力，但是我，就我而言，感觉前途不是很明朗；论经济管理，还不如我学计算机来的收入高。经济基础永远是实现人生理想的基石。不去谈理想。譬如BILIBILI的《后浪》。作为一部宣传片，在五四青年节的契机下发布的。我只觉得极度的恶心。文案不够新颖，一味的鼓励就好像传销给你谈理想。视频内容就更浮夸了。虽然每一项热爱都可以在BILIBILI弹幕网上找到专门的，在某个领域范围内有造诣的UP主。但是总的来说，视频设计的并不是普通老百姓玩得起的。所谓的“后浪”并不是在“前浪”的基础之上实现自己的个人理想的。就算自己觉得不空虚，我也会觉得空虚。这其实本质并不是无产阶级，而是小资产阶级的业余喜好。玩的好的那叫事业，玩的差的永远都是喜好。就最简单的编程，写得好的那叫事业，写的差的那也叫事业。无非就是获取的劳动报酬不一样。至于喜好编程，这个也因人而异，和事业并没有本质联系。 综上所述，我永远热爱编程。 只是换一个方式，不是宇宙机的后台程序开发。而是可以是以后的，或者是更加前瞻性的东西。举个特别乐观的例子：譬如我考研考上了清华大学的计算机学软件工程主攻方向是区块链。 我家里人总是以某个认识的研究生举例。浙江理工毕业，研究生中南大学，一出来年薪25w。我甚至时间的重要性，我总是在想如果我本科能够20w出来，那又如何。虽然现在不及，就好像天方夜谭罢了，但是我认为这只是别人的一条路子罢了，我尽可能的去做到以这个为起步。比起争先恐后的去大厂做码农，感觉继续深造显得更加有趣。]]></content>
      <tags>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java的jvm的虚拟机栈]]></title>
    <url>%2F2019%2F11%2F30%2Fjava%E7%9A%84jvm%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%2F</url>
    <content type="text"><![CDATA[一个小例子论字符串编译之间的区别12345678public class Demo &#123; String s1 = &quot;abc123&quot;; String s2 = &quot;abc&quot;; String s3 = &quot;abc&quot; + &quot;123&quot;; String s4 = s2 + &quot;123&quot;; String s5 = new String(&quot;abc&quot;); String s6 = s5 + &quot;123&quot;;&#125; class文件所生成的字节码文件和当前源文件一不样呢？当然是不一样。 1234567891011121314public class Demo &#123; String s1 = &quot;abc123&quot;; String s2 = &quot;abc&quot;; String s3 = &quot;abc123&quot;; String s4; String s5; String s6; public Demo() &#123; this.s4 = this.s2 + &quot;123&quot;; this.s5 = new String(&quot;abc&quot;); this.s6 = this.s5 + &quot;123&quot;; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java的jvm（持续更新）]]></title>
    <url>%2F2019%2F11%2F16%2F%E7%AC%AC%E5%8D%81%E5%91%A8%E5%91%A8%E4%BC%9A%E5%88%86%E4%BA%AB%EF%BC%88%E5%8F%AF%E6%81%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[java虚拟机内存模型堆堆是java虚拟机里面管理内存最大的一块，它是我们在所有线程所共享的一个内存。此内存区域的唯一目的就是存放对象实例。也就是说我们所有对象、数组都需要在这个堆内存里面进行空间的申请和保存。这块内存也是我们在垃圾收集里面主要的清理的一个区域。所以说也可以说上面GC堆。从内存回收的角度也会有新生代···可以通过-Xmx和-Xms来控制当前的虚拟机内存的大小，如果说堆内存被占满了，程序没有办法申请空间再去分配对象什么的，会爆出OutOfMemoryError异常。 虚拟机栈虚拟机栈是线程私有的，也是和线程生命周期相同，虚拟机栈里面是描述java方法执行的内存模型，我们每个方法在执行的时候，都会创建栈帧。栈帧里面所进行存储（结构）：局部变量表、操作数栈、动态链接和方法出口。局部变量就是编译期间的基本数据类型的或者是对象的引用（指的是当前对象数据在堆里面的地址）如果虚拟机栈里面内存里面没有办法去申请内存保存更多数据（譬如递归会有栈溢出）。操作数栈和局部变量区一样，操作数栈也是被组织成一个以字长为单位的数组。但是和前者不同的是，它不是通过索引来访问，而是通过标准的栈操作——压栈和出栈—来访问的。动态连接 : 虚拟机运行的时候,运行时常量池会保存大量的符号引用，这些符号引用可以看成是每个方法的间接引用。方法的返回分为两种情况：一种是正常退出，退出后会根据方法的定义来决定是否要传返回值给上层的调用者。一种是异常导致的方法结束，这种情况是不会传返回值给上层的调用方法。不过无论是那种方式的方法结束，在退出当前方法时都会跳转到当前方法被调用的位置。如果方法是正常退出的，则调用者的PC计数器的值就可以作为返回地址；如果是因为异常退出的，则是需要通过异常处理表来确定。这个区域规定了两种异常状态：如果线程请求的栈深度大于虚拟机所允许的深度，则抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，在扩展是无法申请到足够的内存，就会抛出OutOfMemoryError异常。 本地方法栈类似于虚拟机栈，区别是虚拟机栈里面保存的是跟我们java系统里面所运行的方法类提供服务的。而我们本地方法栈是为虚拟机去使用当前的一些本地方法去用的。就是一些Native方法。（并不是特别关心） 方法区类似于堆、它也是线程共享的。主要用于存储当前对于虚拟机加载关于类、常量、静态变量或者是一些即时编译后的数据。如果方法区保存数据到临界值了，无法储存了也会说内存溢出。方法区里面有一个运行常量池（Runtime Constant Pool）。在加载java程序的时候，关于类的一些版本，类里面的一些成员变量、方法、接口、一些描述类的信息都会在这里面。还有存放在编译期间的自变量和符号引用。它有个别命叫Non-Heap（非堆）。当方法区无法满足内存分配需求时，抛出OutOfMemoryError异常。 运行时常量池与在JVM堆分配内存(allocate)相比，直接内存分配（allocateDirect）的访问性能更好，但分配较慢。 直接内存直接内存不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域。但这部分区域也被频繁使用，而且也可能导致OutOfMemoryError异常。在JDK1.4中新加入的NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。与在JVM堆分配内存(allocate)相比，直接内存分配（allocateDirect）的访问性能更好，但分配较慢。 程序计数器占的内存小，执行当前字节码行号的记录器。java在多线程，线程轮流切换到时候。一个cpu执行一条线程的指令。譬如执行12345切换。另一个切换123.我们可以通过程序计数器帮我们实现恢复到之前切换走的位置。是线程私有的，用来看线程自己的一个执行的位置，每个线程都有程序计数器，每个线程都有自己独立的计数器，所有线程之间都是互不影响的。 垃圾回收机制算法垃圾回收机制不定时去堆内存中清理不可达对象。不可达的对象并不会马上就会直接回收， 垃圾收集器在一个Java程序中的执行是自动的，不能强制执行，即使能明确地判断出有一块内存已经无用了，是应该回收的，我们也不能强制垃圾收集器回收该内存块。唯一能做的就是通过调用System.gc 方法来”建议”执行垃圾收集器，但其是否可以执行，什么时候执行却都是不可知的。这也是垃圾收集器的最主要的缺点。 12345678910111213public class Test &#123; public static void main(String[] args) &#123; Test test = new Test(); test = null; System.gc(); // 手动回收垃圾 &#125; @Override protected void finalize() throws Throwable &#123; // gc回收垃圾之前调用 System.out.println(&quot;垃圾回收机制...&quot;); &#125;&#125; finalize方法Java技术使用finalize()方法在垃圾收集器将对象从内存中清除出去前，做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在Object类中定义的，所有的类都继承了它。子类覆盖finalize()方法以整理系统资源或者执行其他清理工作。finalize()方法是在垃圾收集器删除对象之前对这个对象调用的。 判断对象是否存活引用计数法引用计数法就是如果一个对象没有被任何引用指向，则可视之为垃圾。这种方法的缺点就是不能检测到环的存在。首先需要声明，至少主流的Java虚拟机里面都没有选用引用计数算法来管理内存。什么是引用计数算法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加１；当引用失效时，计数器值减１.任何时刻计数器值为０的对象就是不可能再被使用的。那为什么主流的Java虚拟机里面都没有选用这种算法呢？其中最主要的原因是它很难解决对象之间相互循环引用的问题。 搜索根算法搜索算法的基本思路就是通过一系列名为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。可以作为GCRoots的对象包括下面几种：(1). 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。(2). 方法区中的类静态属性引用的对象。(3). 方法区中常量引用的对象。(4). 本地方法栈中JNI(Native方法)引用的对象。 java四种引用类型强引用 类似于 Object obj = new Object(); 创建的，只要强引用在就不回收。软引用SoReference 类实现软引用。在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行 二次回收。弱引用 WeakReference 类实现弱引用。对象只能生存到下一次垃圾收集之前。在垃圾收集器工作时，无论内存 是否足够都会回收掉只被弱引用关联的对象。虚引用PhantomReference 类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的 唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 引用类型 用途 被回收时间 生存时间 强引用 对象的一般状态 从来不会 JVM停止运行时终止 软引用 对象缓存 内存不足 内存不足时停止 弱引用 对象缓存 垃圾回收 GC后停止 虚引用 不知道 不知道 不知道 分代算法这种算法，根据对象的存活周期的不同将内存划分成几块，新生代和老年代，新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。新生代对象朝生夕死,对象数量多，只要重点扫描这个区域，那么就可以大大提高垃圾收集的效率。另外老年代对象存储久，无需经常扫描老年代，避免扫描导致的开销。 堆根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。堆大小 = 新生代 + 老年代。其中，堆的大小可以通过参数 –Xms、-Xmx 来指定。默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2( 该值可以通过参数 –XX:NewRatio来指定 )，即：新生代 ( Young ) = 1/3 的堆空间大小。老年代 ( Old ) = 2/3 的堆空间大小。 新生代新的对象实例被创建的时候通常在Eden空间，发生在Eden空间上的GC称为Minor GC，当在新生代发生一次GC后，会将Eden和其中一个Survivor空间的内存复制到另外一个Survivor中，如果反复几次有对象一直存活，此时内存对象将会被移至老年代。可以看到新生代中Eden占了大部分，而两个Survivor实际上占了很小一部分。这是因为大部分的对象被创建过后很快就会被GC 1、新生代的初始值NewSize默认为1M，最大值需要设置，可以通过参数-XX:NewSize和-XX:MaxNewSize或-Xmn进行设置；2、为老年代与新生代的大小比值，默认为2：1；3、SurvivorRatio为新生代中Eden和Survivor的大小比值，默认为8：1 Edem : from : to = 8 :1 : 1 可以通过参数-XX:SurvivorRatio 来设定 )，即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块Survivor 区域是空闲着的。新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。 老年代新生代每进行一次垃圾收集后，就会给存活的对象“加1岁”，当年龄达到一定数量的时候就会进入老年代（默认是15,可以通过-XX：MaxTenuringThreshold来设置）。另外，比较大的对象也会进入老年代，可以-XX：PretenureSizeThreshold进行设置。如-XX：PretenureSizeThreshold3M，那么大于3M的对象就会直接就进入老年代。因此，老年代中存放的都是一些生命周期较长的对象或者特别大的对象。 垃圾回收机制策略标记清除算法该算法有两个阶段。1.标记阶段：找到所有可访问的对象，做个标记2.清除阶段：遍历堆，把未被标记的对象回收 该算法一般应用于老年代,因为老年代的对象生命周期比较长。 标记清除算法的优点和缺点1.优点 是可以解决循环引用的问题 必要时才回收(内存不足时) 2.缺点： 回收时，应用需要挂起，也就是stop the world。 标记和清除的效率不高，尤其是要扫描的对象比较多的时候 会造成内存碎片(会导致明明有内存空间,但是由于不连续,申请稍微大一些的对象无法做到)。 Full GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。现实的生活中，老年代的人通常会比新生代的人”早死”。堆内存中的老年代(Old)不同于这个，老年代里面的对象几乎个个都是在 Survivor 区域中熬过来的，它们是不会那么容易就 “死掉” 了的。因此，Full GC 发生的次数不会有 Minor GC 那么频繁，并且做一次 Full GC 要比进行一次 Minor GC 的时间更长。 复制算法如果jvm使用了coping算法，一开始就会将可用内存分为两块，from域和to域， 每次只是使用from域，to域则空闲着。当from域内存不够了，开始执行GC操作，这个时候，会把from域存活的对象拷贝到to域,然后直接把from域进行内存清理。 优点:在存活对象不多的情况下，性能高，能解决内存碎片。缺点: 会造成一部分的内存浪费。不过可以根据实际情况，将内存块大小比例适当调整；如果存活对象的数量比较大，或者，对象存活率较高时就要进行较多的复制操作，coping的性能会变得很差。 标记压缩算法标记清除算法和标记压缩算法非常相同，但是标记压缩算法在标记清除算法之上解决内存碎片化。 任意顺序 : 即不考虑原先对象的排列顺序，也不考虑对象之间的引用关系，随意移动对象；线性顺序 : 考虑对象的引用关系，例如a对象引用了b对象，则尽可能将a和b移动到一块；滑动顺序 : 按照对象原来在堆中的顺序滑动到堆的一端。 优点:解决内存碎片问题，缺点压缩阶段，由于移动了可用对象，需要去更新引用。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十周小分享]]></title>
    <url>%2F2019%2F11%2F09%2F%E7%AC%AC%E5%8D%81%E5%91%A8%E5%B0%8F%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[神奇姚老板这能输出什么123456789101112131415161718public class Test &#123;static Test test = new Test(&quot;3&quot;);static&#123;System.out.println(&quot;1&quot;);&#125;&#123;System.out.println(&quot;2&quot;);&#125;Test(String s)&#123;System.out.println(s);&#125;public static void staticFunction()&#123;System.out.println(&quot;4&quot;);&#125;public static void main(String[] args) &#123;staticFunction();&#125;&#125; 答案是 12342314 在分配内存是先静态的。静态之间的顺序自上而下。所以先执行 1static Test test = new Test(&quot;3&quot;); 在这个对象里面，也是先运行构造代码块，然后再是构造函数。所以是2然后3然后再执行 123static&#123; System.out.println(&quot;1&quot;);&#125; 最后才是输出4 总结一下1.静态代码块在类被加载的时候就运行了，而且只运行一次，并且优先于各种代码块以及构造函数。如果一个类中有多个静态代码块，会按照书写顺序依次执行。2.构造代码块在创建对象时被调用，每次创建对象都会调用一次，但是优先于构造函数执行。构造代码块不是优先于构造函数执行，而是依托于构造函数，也就是说，如果你不实例化对象，构造代码块是不会执行的。 2如图我给打成代码 1234567891011121314151617181920import java.io.Serializable;public class DataObject implements Serializable &#123; private static int i = 0; private String word = &quot; &quot;; public void setWord(String word) &#123; this.word = word; &#125; public static void setI(int i) &#123; DataObject.i = i; &#125; public static void main(String[] args) &#123; DataObject object = new DataObject(); object.setWord(&quot;123&quot;); object.setI(2); &#125;&#125; 将此对象序列化为文件，并在另外一个JVM中读取文件，进行反序列化，请问此时读出的DataObject对象中的word值和i的值分别为： 在另一个jvm中反序列化i还是0，要是不换jvm就变成2了，word一直是123。 所以说序列化是对 对象，而非类进行的这个、我还在拓展序列化ing。可以看看 312345678910111213class Base&#123; public Base(String s)&#123; System.out.println(&quot;B&quot;); &#125;&#125;public class Dervied &#123; public Dervied(String s)&#123; System.out.println(&quot;D&quot;); &#125; public static void main(String[] args) &#123; new Dervied(&quot;C&quot;); &#125;&#125; 问输出是什么A.BD B.DB C.C D.编译错误答案是并不能输出。因为要super。譬如这样 1234public Dervied(String s)&#123; super(s); System.out.println(&quot;D&quot;); &#125; 41.short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?2.算出2乘以8等于几最有效率的方法是什么？3.java中会存在内存泄漏吗，举例说明。 第一题第一个有问题，int类型的1不能给short类型的s1就算是空间足够，第二个嘛根据查找的java规范 a+=b 实际上是 (T1) a=(T1)(a+b) 所以 就是short型了 就没错来着 第二题嘛，可以直接移动 12byte number1 = 2;byte res = (byte) (number1 &lt;&lt; 2); 第三题嘛一个超长的解释。泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。 但是，即使这样，Java也还是存在着内存泄漏的情况，1、长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露。 尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是Java中内存泄露的发生场景，通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的，这就是Java中可能出现内存泄露的情况，例如，缓存系统，我们加载了一个对象放在缓存中(例如放在一个全局map对象中)，然后一直不再使用它，这个对象一直被缓存引用，但却不再被使用。检查java中的内存泄露，一定要让程序将各种分支情况都完整执行到程序结束，然后看某个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。 如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。 2、当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露。 51String s = new String(&quot;xyz&quot;); 创建了几个StringObject？A.两个或一个都有可能 B.两个 C.一个 D.三个 共产生了两个2个对象，第一个是字符串常量xyz,存储于常量池中。第二个对象是new String（）时产生的s，存储于堆中。 612345678public class NULL &#123; public static void haha()&#123; System.out.println(&quot;haha&quot;); &#125; public static void main(String[] args) &#123; ((NULL)null).haha(); &#125;&#125; 能正常运行吗？！可以，并且成功输出了haha。如果改成实例方法，并不可以。 12345678public class NULL &#123; public void haha()&#123; System.out.println(&quot;haha&quot;); &#125; public static void main(String[] args) &#123; ((NULL)null).haha(); &#125;&#125; Exception in thread “main” java.lang.NullPointerException at NULL.main(NULL.java:6)空指针异常。因为null值可以强制转换为任何java类类型,(String)null也是合法的。但null强制转换后是无效对象，其返回值还是为null，而static方法的调用是和类名绑定的，不借助对象进行访问所以能正确输出。反过来，没有static修饰就只能用对象进行访问，使用null调用对象肯定会报空指针错了。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子类获取父类的父类的属性和方法]]></title>
    <url>%2F2019%2F11%2F01%2Fjava%E5%AD%90%E7%B1%BB%E8%8E%B7%E5%8F%96%E7%88%B6%E7%B1%BB%E7%9A%84%E7%88%B6%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[问题源自于招新培训的时候，我听课时候的灵光一现。如果是中国人继承于人类，但是浙江人又继承于中国人，怎么才能获得父类的父类的方法。我寻思了一下有三种。 1.在父类里面建立super.爷类的方法。然后子类重写的同时里面super.也是调用自己父类的方法可以实现。12345678910111213141516171819class Grandfather&#123; String a = &quot;爷爷&quot;;&#125;class Father extends Grandfather&#123; String a = &quot;爸爸&quot;; String getGrandfatherName()&#123; return super.a; &#125;&#125;class Son extends Father&#123; String a = &quot;孙子&quot;; String getGrandfatherName()&#123; return super.getGrandfatherName(); &#125;&#125; 2.利用反射的特性，利用类方法直接获取。这种和子不子类，继承不继承无关。也不能这么说，假设我只是知道我是继承的父类，然后可以知道我父类继承的爷爷类，一直到太爷爷类都可以。类方法取出。 3.可以用虚拟机级别的invokeddynamic实现（基于java1.7版本以及以上才可以）太高深了 以下cv1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * @(#)Text4.java * * * @author * @version 1.00 2016/12/6 */import java.lang.invoke.MethodHandle;import java.lang.invoke.MethodType;import static java.lang.invoke.MethodHandles.lookup; public class Text4 &#123; class GrandFather&#123; void thinking()&#123; System.out.println(&quot;i am grandfather&quot;); &#125; &#125; class Father extends GrandFather&#123; void thinking()&#123; System.out.println(&quot;i am father&quot;); &#125; &#125; class son extends Father&#123; void thinking()&#123; try&#123; MethodType mt = MethodType.methodType(void.class); MethodHandle mh = lookup().findSpecial(GrandFather.class, &quot;thinking&quot;, mt, getClass()); mh.invoke(this); &#125;catch(Throwable e)&#123; &#125; &#125; &#125; public static void main(String[] args)&#123; (new Text4().new son()).thinking(); &#125; &#125; 对上述代码使用生成class字节码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168Classfile /E:/JAVAprojects/noMain/bin/noMain/son.class Last modified 2016-12-6; size 1386 bytes Compiled from &quot;son.java&quot;public class noMain.son extends noMain.Father minor version: 0 major version: 51 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Class #2 // noMain/son #2 = Utf8 noMain/son #3 = Class #4 // noMain/Father #4 = Utf8 noMain/Father #5 = Utf8 &lt;init&gt; #6 = Utf8 ()V #7 = Utf8 Code #8 = Methodref #3.#9 // noMain/Father.&quot;&lt;init&gt;&quot;:()V #9 = NameAndType #5:#6 // &quot;&lt;init&gt;&quot;:()V #10 = Utf8 LineNumberTable #11 = Utf8 LocalVariableTable #12 = Utf8 this #13 = Utf8 LnoMain/son; #14 = Utf8 thinking #15 = Methodref #16.#18 // java/lang/Object.getClass:()Ljava/lang/Class; #16 = Class #17 // java/lang/Object #17 = Utf8 java/lang/Object #18 = NameAndType #19:#20 // getClass:()Ljava/lang/Class; #19 = Utf8 getClass #20 = Utf8 ()Ljava/lang/Class; #21 = Fieldref #22.#24 // java/lang/Void.TYPE:Ljava/lang/Class; #22 = Class #23 // java/lang/Void #23 = Utf8 java/lang/Void #24 = NameAndType #25:#26 // TYPE:Ljava/lang/Class; #25 = Utf8 TYPE #26 = Utf8 Ljava/lang/Class; #27 = Methodref #28.#30 // java/lang/invoke/MethodType.methodType:(Ljava/lang/Class;)Ljava/lang/invoke/MethodType; #28 = Class #29 // java/lang/invoke/MethodType #29 = Utf8 java/lang/invoke/MethodType #30 = NameAndType #31:#32 // methodType:(Ljava/lang/Class;)Ljava/lang/invoke/MethodType; #31 = Utf8 methodType #32 = Utf8 (Ljava/lang/Class;)Ljava/lang/invoke/MethodType; #33 = Methodref #34.#36 // java/lang/invoke/MethodHandles.lookup:()Ljava/lang/invoke/MethodHandles$Lookup; #34 = Class #35 // java/lang/invoke/MethodHandles #35 = Utf8 java/lang/invoke/MethodHandles #36 = NameAndType #37:#38 // lookup:()Ljava/lang/invoke/MethodHandles$Lookup; #37 = Utf8 lookup #38 = Utf8 ()Ljava/lang/invoke/MethodHandles$Lookup; #39 = Class #40 // noMain/GrandFather #40 = Utf8 noMain/GrandFather #41 = String #14 // thinking #42 = Methodref #43.#45 // java/lang/invoke/MethodHandles$Lookup.findSpecial:(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle; #43 = Class #44 // java/lang/invoke/MethodHandles$Lookup #44 = Utf8 java/lang/invoke/MethodHandles$Lookup #45 = NameAndType #46:#47 // findSpecial:(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle; #46 = Utf8 findSpecial #47 = Utf8 (Ljava/lang/Class;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle; #48 = Methodref #49.#51 // java/lang/invoke/MethodHandle.invoke:(LnoMain/son;)V #49 = Class #50 // java/lang/invoke/MethodHandle #50 = Utf8 java/lang/invoke/MethodHandle #51 = NameAndType #52:#53 // invoke:(LnoMain/son;)V #52 = Utf8 invoke #53 = Utf8 (LnoMain/son;)V #54 = Class #55 // java/lang/Throwable #55 = Utf8 java/lang/Throwable #56 = Utf8 a #57 = Utf8 mt #58 = Utf8 Ljava/lang/invoke/MethodType; #59 = Utf8 mh #60 = Utf8 Ljava/lang/invoke/MethodHandle; #61 = Utf8 StackMapTable #62 = Class #63 // java/lang/Class #63 = Utf8 java/lang/Class #64 = Utf8 main #65 = Utf8 ([Ljava/lang/String;)V #66 = Methodref #1.#9 // noMain/son.&quot;&lt;init&gt;&quot;:()V #67 = Methodref #1.#68 // noMain/son.thinking:()V #68 = NameAndType #14:#6 // thinking:()V #69 = Utf8 args #70 = Utf8 [Ljava/lang/String; #71 = Utf8 SourceFile #72 = Utf8 son.java #73 = Utf8 InnerClasses #74 = Utf8 Lookup&#123; public noMain.son(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #8 // Method noMain/Father.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 32: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this LnoMain/son; void thinking(); descriptor: ()V flags: Code: stack=5, locals=4, args_size=1 0: aload_0 1: invokevirtual #15 // Method java/lang/Object.getClass:()Ljava/lang/Class; 4: astore_1 5: getstatic #21 // Field java/lang/Void.TYPE:Ljava/lang/Class; 8: invokestatic #27 // Method java/lang/invoke/MethodType.methodType:(Ljava/lang/Class;)Ljava/lang/invoke/MethodType; 11: astore_2 12: invokestatic #33 // Method java/lang/invoke/MethodHandles.lookup:()Ljava/lang/invoke/MethodHandles$Lookup; 15: ldc #39 // class noMain/GrandFather 17: ldc #41 // String thinking 19: aload_2 20: aload_1 21: invokevirtual #42 // Method java/lang/invoke/MethodHandles$Lookup.findSpecial:(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle; 24: astore_3 25: aload_3 26: aload_0 27: invokevirtual #48 // Method java/lang/invoke/MethodHandle.invoke:(LnoMain/son;)V 30: goto 34 33: astore_2 34: return Exception table: from to target type 5 30 33 Class java/lang/Throwable LineNumberTable: line 36: 0 line 38: 5 line 39: 12 line 40: 15 line 41: 17 line 40: 21 line 39: 24 line 43: 25 line 44: 30 line 47: 34 LocalVariableTable: Start Length Slot Name Signature 0 35 0 this LnoMain/son; 5 30 1 a Ljava/lang/Class; 12 18 2 mt Ljava/lang/invoke/MethodType; 25 5 3 mh Ljava/lang/invoke/MethodHandle; StackMapTable: number_of_entries = 2 frame_type = 255 /* full_frame */ offset_delta = 33 locals = [ class noMain/son, class java/lang/Class ] stack = [ class java/lang/Throwable ] frame_type = 0 /* same */ public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=1, args_size=1 0: new #1 // class noMain/son 3: dup 4: invokespecial #66 // Method &quot;&lt;init&gt;&quot;:()V 7: invokevirtual #67 // Method thinking:()V 10: return LineNumberTable: line 53: 0 line 55: 10 LocalVariableTable: Start Length Slot Name Signature 0 11 0 args [Ljava/lang/String;&#125;SourceFile: &quot;son.java&quot;InnerClasses: public static final #74= #43 of #34; //Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles 没有生成invokedynamic调用，应该是我的jvm配置出错，使得jvm栈帧的模式值调用了出栈的第一个实例使得输出答案为 i am father 虚拟机级别动态分配调用方法代码： 123456789101112131415161718192021222324252627282930313233343536373839/** * @(#)StaticDispatch.java * * * @author * @version 1.00 2016/12/6 */ import java.lang.invoke.*;import java.lang.invoke.CallSite;import java.lang.invoke.ConstantCallSite;import java.lang.invoke.MethodHandle;import java.lang.invoke.MethodHandles;import java.lang.invoke.MethodType;import static java.lang.invoke.MethodHandles.lookup; public class StaticDispatch &#123; static class ClassA&#123; public void println(String s)&#123; System.out.println(s); &#125; &#125; private static MethodHandle getPrintlnMH(Object recevier) throws Throwable&#123; MethodType mt = MethodType.methodType(void.class,String.class); return lookup().findVirtual(recevier.getClass(),&quot;println&quot;,mt).bindTo(recevier); &#125; public static void main(String[] args) throws Throwable&#123; Object ob = System.currentTimeMillis() % 2 == 0 ? System.out : new ClassA(); getPrintlnMH(ob).invokeExact(&quot;invoke println&quot;); &#125; &#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bean的加载方式]]></title>
    <url>%2F2019%2F10%2F29%2FBean%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[没错，这就是姗姗来迟的Bean的加载方式。 通过xml方式加载Bean1.最最淳朴的xml加载一个User类 1234567891011121314151617181920public class User &#123; private int id; private String name; public String getName() &#123; return name; &#125; public void setId(int id) &#123; this.id = id; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getId() &#123; return id; &#125;&#125; spring.xml里面的配置 1234&lt;bean id=&quot;user&quot; class=&quot;com.spring.test.bean.User&quot; &gt; &lt;property name=&quot;name&quot; value=&quot;4399&quot;&gt;&lt;/property&gt; &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 测试代码 1234567private ClassPathXmlApplicationContext context;@org.junit.Test public void text1()&#123; User user = (User)context.getBean(&quot;user&quot;); System.out.println(user); &#125; 2.通过Bean工厂加载Bean一个加载User的Bean工厂 12345678public class UserFactory &#123; public static User careateUser()&#123; User user = new User(); user.setId(2); user.setName(&quot;7k7k&quot;); return user; &#125;&#125; spring.xml里面的配置 1&lt;bean id=&quot;userFactory&quot; class=&quot;com.spring.test.bean.UserFactory&quot; factory-method=&quot;careateUser&quot;&gt;&lt;/bean&gt; 测试代码 1234567private ClassPathXmlApplicationContext context;@org.junit.Test public void text2()&#123; User user = (User)context.getBean(&quot;userFactory&quot;); System.out.println(user); &#125; 通过注解方式加载Bean3.通过在类上添加注解让xml识别是bean组件。@Component只要注解包含@Component均可（衍生类 @Repository @Service @Controller），相当于把这个类直接变成一个Bean组件。UUser类 12345678910111213141516171819202122@Controllerpublic class UUser &#123; private int id = 3; private String name = &quot;3366&quot;; public String getName() &#123; return name; &#125; public void setId(int id) &#123; this.id = id; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getId() &#123; return id; &#125;&#125; 因为这是让bean工厂能够看出来这是一个Bean，所以还要在xml里面进行扫描。Bean的名字默认就是类的名字开头小写，可以在注解后面如@Component(“person”)来自定义名字 1&lt;context:component-scan base-package=&quot;com.spring.test.bean&quot;/&gt; 测试代码 12345@org.junit.Test public void text3()&#123; UUser user = (UUser)context.getBean(&quot;UUser&quot;); System.out.println(user); &#125; 4.完全不通过xml，通过@Configuration标注类，@Bean标注提供Bean方法123456789101112@Configurationpublic class SpringConfig &#123; @Bean(&quot;user&quot;) public User user1()&#123; User user = new User(); user.setName(&quot;43999&quot;); user.setId(4); return user; &#125;&#125; 测试类 1234567@org.junit.Test public void text5()&#123; AnnotationConfigApplicationContext context1 = new AnnotationConfigApplicationContext(SpringConfig.class); User user = (User)context1.getBean(&quot;user&quot;); System.out.println(user); &#125; 5.最最最后一种，我寻思这个dsy根本想不到的。通过@Configuration标注类，然后类里面的@Bean不通过自己生成，而去其他包下@ComponentScan(basePackages = “com.spring.test.bean”)扫描。这里扫描的是我之前的第三个UUser的方式，因为他自己加了注解，自己作为一个Bean 12345@Configuration@ComponentScan(basePackages = &quot;com.spring.test.bean&quot;)public class SpringConfig2 &#123;&#125; 测试代码 12345678@org.junit.Test public void text6()&#123; AnnotationConfigApplicationContext context1 = new AnnotationConfigApplicationContext(SpringConfig2.class); UUser user = (UUser)context1.getBean(&quot;UUser&quot;); System.out.println(user); &#125; 下一篇更新我自己看的ioc的源码分析，估计更新要一年。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java的懒加载]]></title>
    <url>%2F2019%2F10%2F11%2Fjava%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[懒加载FatchType.LAZY也称为延迟加载，是Hibernate3关联关系对象默认的加载方式，所谓懒加载就是当在真正需要数据的时候，才真正执行数据加载操作。简单理解为，只有在使用的时候，才会发出sql语句进行查询。懒加载的有效期是在session打开的情况下，当session关闭后，会报异常。当调用load方法加载对象时，返回代理对象，等到真正用到对象的内容时才发出sql语句。急加载FatchType.EAGER 也成为立即加载，时立即执行sql语句。在session没有关闭的之前，如果访问除id外的其他属性才会发sql语句去查询，我们经常犯的一个错误就是在当前session关闭以后访问由load（）加载的对象的非id属性，此时Hibernate尝试通过当前session发sql查询，但发现session已经关闭，这样就会发出no session的异常 。 cv的，根本不懂。以后用到Hibernate再说吧。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Journey to Chengdu]]></title>
    <url>%2F2019%2F10%2F08%2FJourney-to-Chengdu%2F</url>
    <content type="text"><![CDATA[Journey to Chengdu]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java的自定义注解]]></title>
    <url>%2F2019%2F09%2F21%2Fjava%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[首先注解是什么Java注解又称Java标注，是Java语言5.0版本开始支持加入源代码的特殊语法元数据。为我们在代 码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便的使用这些数据。 Java语言中的类、方法、变量、参数和包等都可以被标注。和Javadoc不同，Java标注可以通过反 射获取注解内容。在编译器生成类文件时，注解可以被嵌入到字节码中。Java虚拟机可以保留注 解内容，在运行时可以获取到注解内容。（看不看一样，知道就是了） 不是自定义的java的内置注解@Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有 该方法时，会报编译错误。@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。 @SuppressWarnings - 指示编译器去忽略注解中声明的警告。 从 Java 7 开始，额外添加了 3 个注解:@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产 生的警告。 @FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。 源码注解 注解只在源码中存在，编译.class文件之后就不存在了编译时注解 在源文件和.class文件中都会存在，eg：@Override运行时注解 在运行阶段起作用，甚至影响程序的运行逻辑，eg：@Autowired 这里是真正的自定义注解定义注解类 123public @interface MyService&#123; //@interface声明注解&#125; 注解的注解 1234@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;) @Retention(RetentionPolicy.RUNTIME) @Inherited @Documented 元注解（注解的注解）@Target作用域 Construtor：构造方法 Field：字段声明 Type：类或接口 Local_Variable：局部变量 Method：方法 Package：包声明 Parameter：参数声明@Retention声明周期 Source：只在源码显示，编译时会丢弃 Class：编译时记录到class中，运行时忽略 Runtime：运行时存在，可以在运行时利用反射读取@Inherited允许子类继承@Documented生成javadoc时，会包含注解 定义注解内容123456789101112@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;) @Retention(RetentionPolicy.RUNTIME) @Inherited @Documented public @interface MyController &#123; // @interface 声明注解 // 注解的成员规则：必须声明无参数无异常 String url(); String email(); // 可以使用default给成员默认值 int age() default 20; // 成员的类型有限定： // 合法的类型包括：基本类型、String、Class、Annotation、Enumeration // 如果注解只有一个成员，则成员必须取名value()，在使用的时候可以忽略成员名和赋值符 (=) 一个小demo1234567891011121314151617@MyController(url = &quot;baidu.com&quot;, email = &quot;123@qq.com&quot;, age = 10) public class TestAnno &#123; @MyController(age = 22) private int age; @MyController(val = &quot;123456&quot;) private String password; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; &#125; 获取注解类 1234567891011121314151617181920212223242526272829303132333435363738public class ParseAnno &#123; public static void main(String[] args) throws Exception &#123; // 解析注解 Class&lt;?&gt; annoClazz = Class.forName(&quot;XXX.TestAnno&quot;); // 判断类 注解是否存在 boolean exist = annoClazz.isAnnotationPresent(MyController.class); if (exist) &#123; // 存在 // 获取注解 MyController classAnno = annoClazz.getAnnotation(MyController.class); // 打印注解值 System.out.println(classAnno.email()); &#125; // 获取类中成员变量的注解 Field[] fields = annoClazz.getDeclaredFields(); // 获取类中所有 的成员变量 for (Field f : fields) &#123; // 判断成员变量，注解是否存在 boolean fieldExist = f.isAnnotationPresent(MyController.class); if (fieldExist) &#123; // 获取注解 MyController fieldAnno = f.getAnnotation(MyController.class); // 输出成员变量注解的值 System.out.println(&quot;age = &quot; + fieldAnno.age()); System.out.println(&quot;val = &quot; + fieldAnno.val()); &#125; &#125; &#125; &#125; 几点回忆得起的有的没得一般都是 运行时候的注解@Override就是个标识注解，没什么用就给你看看，知道这是继承。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java虚拟机的类加载]]></title>
    <url>%2F2019%2F09%2F21%2Fjava%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[虚拟机的类加载机制虚拟机把描述类的数据从Class文件加载到内存，对数据校验，转换解析和初始化形成虚拟机可以直接使用的Java类型。 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验 证、准备、解析、初始化、使用和卸载七个阶段。其中验证、准备和解析三个部分统称为连接。 当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始 化三步来实现这个类进行初始化。 加载加载就是虚拟机查找.class，并创建一个java.lang.Class的对象，将类的.class文件中的二进制数据读入内存，放在运行时区域的方法区内。然后在堆中创建 java.lang.Class 对象，用来封装类在方法区的数据结构。 （1）Java虚拟机将.class文件读入内存，并为之创建一个Class对象。 （2）任何类被使用时系统都会为其创建一个且仅有一个Class对象。（3）这个Class对象描述了这个类创建出来的对象的所有信息 链接链接包括验证、准备以及解析三个阶段。（1）验证阶段。主要的目的是确保被加载的类（.class文件的字节流）满足Java虚拟机规范，不 会造成安全错误。 （2）准备阶段。负责为类的静态成员分配内存，并设置默认初始值。 （3）解析阶段。将类的二进制数据中的符号引用替换为直接引用。 说明： 符号引用。即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变 量，一个类的相关信息。直接引用。可以理解为一个内存地址，或者一个偏移量。比如类方法，类变量的直接引用 是指向方法区的指针；而实例方法，实例变量的直接引用则是从实例的头指针开始算起到这个实例变量位置的偏 移量。举个例子，现在调用方法hello()，这个方法的地址是0xaabbccdd，那么hello就是符号引用， 0xaabbccdd就是直接引用。在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地 址或偏移量，也就是直接引用。 初始化初始化，则是为标记为常量值的字段赋值的过程。换句话说，只对static修饰的变量或语句块进行初始 化。如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。 怎么说呢类加载只是一个类的生命周期的一部分。先编译才能有class文件使用后还会有垃圾回收 在自己的项目里新建一个java.lang包，里面新建了一个String类，能代替系统String吗不能，因为根据类加载的双亲委派机制，会将请求转发给父类加载器，父类加载器发现冲 突了String就不会加载了。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[It's just humiliating love]]></title>
    <url>%2F2019%2F08%2F29%2F%E6%9F%AF%E4%BA%BA%E6%9C%89%E4%BA%86%E7%94%B7%E6%9C%8B%E5%8F%8B%2F</url>
    <content type="text"><![CDATA[It’s just humiliating love]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前序]]></title>
    <url>%2F2019%2F08%2F17%2F%E5%91%90%E5%96%8A%2F</url>
    <content type="text"><![CDATA[这是我的博客的开始我在年青时候也曾经做过许多梦，后来大半忘却了，但自己也并不以为可惜。所谓回忆者，虽说可以使人欢欣，有时也不免使人寂寞，使精神的丝缕还牵着已逝的寂寞的时光，又有什么意味呢，而我偏苦于不能全忘却，这不能全忘的一部分，到现在便成了“金清老贼的博客”的来由。]]></content>
      <tags>
        <tag>寻论</tag>
      </tags>
  </entry>
</search>
