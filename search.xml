<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[从卸载虎扑说起]]></title>
    <url>%2F2020%2F05%2F09%2F%E4%BB%8E%E5%8D%B8%E8%BD%BD%E8%99%8E%E6%89%91%E8%AF%B4%E8%B5%B7%2F</url>
    <content type="text"><![CDATA[给个链接，刚刚发的一个帖子女朋友是大二前端开发者，准备选购macbook pro求jrs推荐.永久不删除我真的就是觉得很普普通通的一个文章，结果被我自吴亦凡和虎扑因《新说唱》的互怼而加入jrs的阵营以来，对虎扑感觉有着前所未有的失望。一个个人都不知道算成什么样子。虽然说是直男的论坛一起玩玩发发帖子都还挺好。也会有一些莫名其妙的抖机灵。和以前的贴吧/天涯论坛一样，会有很多精品的帖子出现。但是总的学历水平估计还是挺低的。就目前看来可能平均学历并没有多高。我也参与过投票，某种月经帖，jrs的学历。密密麻麻，从小学开始，初中······一直到院士。投票总是院士最多，也就随随便便打趣便是了。 但是我发的帖子确实没想到，就老老实实问一个什么电脑好。 真的离谱，为了咨询一个合适的电脑就还要把自己的github仓库搬出来说这是我自己的仓库你们去看吧？就前后端都可能没搞清楚是什么意思在质疑一些莫名其妙的东西。 我就搞了这么一个回复：“我来统一回复一下。 目的就只是为了咨询一下电脑。我觉得i5，8代也不是不能打一般都够用了，但是这东西肯定越新越好。但是内存还是16g好一点。我自己8g，譬如跑一个idea，外加一个浏览器，开两个qq内存就满了。 至于前端开不开发原则上来说和大二没什么关系。主要是说自己的收入不是很高，最多最多也就是靠着赚外快，接点外包赚点小钱，也都高兴。那至于好奇的是不是还要github仓库给你们康康。我不知道我女朋友写的怎么样。反正我自己的后台管理少用了很多技术，要学的太多了。但是至少就springboot+mysql能跑得通玩得成任务倒是可以保证。不会有人真的以为就算是计算机专业靠着学校这些就够给你找到步行街街薪了8⃣️？总得慢慢学习的嘛。 学校的一些计算机网络，数据结构这些挺好，但是不一定教你spring全家桶这些。总得还是要靠自己自学的。就是你不自学，就是你毕业当了个程序员了，还不是几年后被裁。 总而言之就是，称呼什么样的无所谓你觉得是就是，你觉得不是就不是。反正我觉得是，这个帖子的目的只是为了讨论决赛圈的电脑那个更加契合。她说想省点钱，我说还是冲16g内存的好。屏幕也问过了16寸不是刚需，用不到这么大的，反而还会感觉有点大，不太方便。id是重庆邮电大学仙居招生办的说掌握这么这么多。我寻思我和你可能还是校友，如果你家在仙居我和你都还是老乡。我寻思这前端也用不到数据库吧。就算是如此，那也不是一年，大二了，都快升大三了，按照课程来你说的也都差不多。 id是唠嗑创造纸巾王朝的：这个大基础应该是Java基础吧。你可能花的时间少罢了，或者你可以考虑考虑换一个方向学习。 id：就是为了试试改名。讲道理，你是最酸的 id：至爱戴维斯。我觉得吧你打lol开120帧和30帧就是不一样。能够在自己承受的范围内舒服一点为什么不好呢？你以前两三千的也可以是没问题。你更加量入为出，我感觉我比较量入为出罢了。 此后的帖子应该不回复了。” 那还就叫一个脾气好。真的酸到根部。网上太容易吵架了。 前天想着打lol老老实实上一波分，结果一个下午到网上，三把彻彻底底队友吵起来。有一把一级团送了两个头，二级中单被对面两把长剑的男刀单杀，男刀二级的伤害是真的看不懂。但是我寻思也不应该为了这几个兵就硬着头铁。后来上单被对面打野抓死，我们打野也死了。打野就挂机了。其实并不是不能打，我自己的下路也算均是。但是打野就这么挂机了。说了句：“你们自己玩吧，再见。”想必这种人在哪里都是失意的吧。没有责任心的人，能是什么好东西。就算要退，譬如15分钟的时候建议投降，必输的局没必要折磨了诸如此类的。但是自己四分钟挂机原本可能赢的就不可能了。真的低等人。 低等人见得多了我这里想到什么骂什么。 说什么逢年过节男人送女人什么。我始终认为送东西属于情分而不是本分，不管是男女朋友还是夫妻。根据价值观的不同会有不同体现。譬如女人认为就应该送，结果男人没送。就算女人没有说出来。但是心里的失望还是会积攒的。但是为什么要积攒？从来就不应该有这种一味的自以为是的索取。我寻思这种观念就是恶心的资本家做的。所有的美好的节日只要被冠以购物街就会变得恶臭（没有例外，不会有例外）。譬如之前的三八国际劳动妇女节，硬要说什么女王节，女神节。这就离谱的一批。无非就是看着女人容易花钱呗。其实男人女人都很容易花钱，不一样的就是，想要骗到男人的钱比骗到女人的钱要难多了。 都说出去玩AA啊什么的。在我看来理应经济能力分配。一方高收入，一方低收入。高收入可适当分担一部分低收入的开销（关系好的话）。关系差的就别出来玩了，就同凉面。别拌了，真不熟。但是在社会地位上来说，男方应该承担大头或者全部的费用。确实在这个社会上男人的确实要比女人强势，女人所受到的不公要多余男人所受到的不公。但是如果想要做到男女平等就要在基础之消除这一偏见。指的就是男女理应AA。要真正的声明女权绝不应该是自己安然自若吃尽便宜。该花多少的就该花多少，花不起就别出来玩。但凡是想着白吃白喝的总是会低人一等。 就极端一点来说，拿着被包养的钱，谈什么独立人格，谈什么人生理想，我就觉得这也太奇怪了。逢年过节是应该，也是可以准备准备什么惊喜礼物什么的。但是那也得靠一个人的经济条件来说的。譬如就大学男女谈恋爱。过个圣诞节，两个人都是普普通通的1500零花钱过日子的人。女方突然提出要求说要原价1000rmb，现价只要800rmb的神仙水。这就很离谱了，这种垃圾还是趁早被中年大叔包养来的实在。可以做到的譬如请吃饭什么的。总得想想实际的，真实的。不是每个人都是bilibili《后浪》里的人物。没有上一辈的资本，靠着自己白手起家。玩电竞，手办模型。玩出点名堂确实不是一件容易的事情。搞这种还不如去买个彩票还容易中奖一点。兴趣归兴趣，若要是作为职业还得要三思。 先前说到了为什么总是想着女人购物，因为女人的钱太好骗了。而受苦的是给那些女人钱的男人或者但但是那些女人自己的钱包。我几个星期前和我姐姐碰了次面。他说下个月买一个xbox还是ps4的。我对这个兴趣倒不是很大。我说你不打算存钱结婚吗？她说结婚我需要花钱吗？确实是这么一个道理。可以不花钱，女方父母只负责拿彩礼，女方只负责貌美如花，拎包入住。这也有着的活法罢了。但是想要自己过得舒服，那势必要自己也该承担点责任。最浅显的就是，老了就不是貌美如花。不要总是想着自己吃一些看似是便宜的事情。人格上的低劣可不是说说就能挽回的。但凡自己把自己物化了，精神世界只会更加空虚罢了。 微博倒是有很多女权的事情。我是真的没有这么多的时间，没有这么多的经历去纠结这种事情。同理，新浪微博也是个罪魁祸首，就是这些无量平台使得当代中国乌烟瘴气。那些下班在家里洗衣服被下班后在外面喝酒回家耍酒疯的男人欺负的女人才不会高强度微博在线。那些女权微博究竟要diss的是什么东西我至今都没搞清楚。或者说就是想什么时候才可以仅她们所想。恰好想买双椰子350的时候出来一张椰子350券，且仅本人本次可用。 女拳们总是想方设法将自己化生为正义的都是，其实这也是叫不醒装睡的人。可能自己赚了一大波钱罢了，顺带声明一下自己的人类灭绝计划。总是借着小事情絮絮叨叨。就好似你去和一个小面馆的老板说其实读书很有用的。小面馆的老板说自己小学文凭，一年收入15w，自己儿子本科毕业只能找到3k一个月的工作。然后他又想到了，隔壁张大婶家的儿子，高中读的是职高，学了一手数控车床，现在一年能赚其10多w，李大娘家的女儿，无心读书，给他买到了某个大专，一年学费2.5w，结果出来找不到工作。总是想借着个别案例去驳斥基本事实。 一般来说本科毕业的平均月薪就是比专科的高，专科的更比小学毕业的高。只是个别不一样罢了。 女拳也会有反对结婚，恶心男人。其实从平等的角度来说，男人也不一定喜欢结婚，结婚也同样是男人的枷锁，所有套在女人身上的词几乎都可以套给男人。 总是念念不忘的子宫。那小孩子女人不生难道还男人生？要么你找个人做丁克算了。 总是念念不忘冠姓权。其实我觉得姓，理应跟着男方姓，先不说向往的西方资本主义的Mrs.是什么意思。我觉得这原本应该是作为缓解社会矛盾的基本准则。如果达成社会的默认事实也无不可，就不至于总是争吵。但是个别案例个别讨论。譬如女方是独生子女，男方有一个弟弟的情况还是从情分来说应该和女方姓。并不是女拳不女拳的问题，应该是男人厕所有专门尿尿地方女人没有的事情，司空见惯的罢了。 一个人要是渴望幸福就得先有幸福的资本。我还要批评恶心的抖音/快手里面买丑的。譬如做一些傻逼发明的，譬如就砸冰发出恶心笑声的，再例如在虎牙开直播的药水哥，以及阿giao。都是最最垃圾的，要说最有文化的还是药水哥。但是这个人的吃相是真的差。 如果都是说对眼的话就是正确的话，那还会有几个人会坚持捍卫人的尊严不写了，本文完。]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[准备考研了]]></title>
    <url>%2F2020%2F05%2F08%2F%E5%87%86%E5%A4%87%E8%80%83%E7%A0%94%E4%BA%86%2F</url>
    <content type="text"><![CDATA[嗯嗯，确实准备考研了如题之前断更了，很长时间。打算接下来的一些时间给自己的博客完善一下。都是很多的大佬提供的方法，我们只是使用它，又不是什么难事。本文只是说我准备考研了。断更也并不是说我不是在读书，再摸鱼啊什么的。其实只是没有记录而已。做了两个项目，感觉自己学的太少了。姚秋鸿总是说我别想着他，他学的少。其实还不是比我多。我对自己没什么信心。都说就业难我也知道，但是工作室总是有人才出现，讲真的人才不管在哪里都是人才。譬如隔壁工作室的哪个浙江人，一看就是兢兢业业学技术的料。也没什么七情六欲。那个人在我寝室对面，他们同寝室的称之为电竞荒漠。但是其实人家肚子里东西是个海洋。 邓思远要我考虑学技术是不是应该继续学下去。确实我有懒，我也不知道为什么总是做不出来东西。我也不会去怪别人。自己的事情还是得自己说了算的。我也并不是说Java不行了。我只是觉得我的Java前途不太光明。我也不会去和别人比。别人学Java出来毕业年薪25w，而我只有15w。其实我现在目标15w就可以了，我也没什么大梦想。但是我觉得这条路子有点行不太通。现在学习编程的人太多了，回头出去还是搬砖。也许和搬砖工差别就在于，更加体面了。永远都需要不断的学习，而且依个人能力以及努力程度决定会不会中年被开除。累死累活还是这一条路罢了。 既然都是依照个人才能为祖国的建设奉献，那这么多人抢着这一条路奉献，我又能怎么样呢？ 我本是想一个契机，一个跳板选了学校并不选专业。但是既然没有成功转专业，那我的本科只能是电子商务了。论计算机，不如继续在工作上共同努力，但是我，就我而言，感觉前途不是很明朗；论经济管理，还不如我学计算机来的收入高。经济基础永远是实现人生理想的基石。不去谈理想。譬如BILIBILI的《后浪》。作为一部宣传片，在五四青年节的契机下发布的。我只觉得极度的恶心。文案不够新颖，一味的鼓励就好像传销给你谈理想。视频内容就更浮夸了。虽然每一项热爱都可以在BILIBILI弹幕网上找到专门的，在某个领域范围内有造诣的UP主。但是总的来说，视频设计的并不是普通老百姓玩得起的。所谓的“后浪”并不是在“前浪”的基础之上实现自己的个人理想的。就算自己觉得不空虚，我也会觉得空虚。这其实本质并不是无产阶级，而是小资产阶级的业余喜好。玩的好的那叫事业，玩的差的永远都是喜好。就最简单的编程，写得好的那叫事业，写的差的那也叫事业。无非就是获取的劳动报酬不一样。至于喜好编程，这个也因人而异，和事业并没有本质联系。 综上所述，我永远热爱编程。 只是换一个方式，不是宇宙机的后台程序开发。而是可以是以后的，或者是更加前瞻性的东西。举个特别乐观的例子：譬如我考研考上了清华大学的计算机学软件工程主攻方向是区块链。 我家里人总是以某个认识的研究生举例。浙江理工毕业，研究生中南大学，一出来年薪25w。我甚至时间的重要性，我总是在想如果我本科能够20w出来，那又如何。虽然现在不及，就好像天方夜谭罢了，但是我认为这只是别人的一条路子罢了，我尽可能的去做到以这个为起步。比起争先恐后的去大厂做码农，感觉继续深造显得更加有趣。]]></content>
      <tags>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java的jvm的虚拟机栈]]></title>
    <url>%2F2019%2F11%2F30%2Fjava%E7%9A%84jvm%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%2F</url>
    <content type="text"><![CDATA[一个小例子论字符串编译之间的区别12345678public class Demo &#123; String s1 = &quot;abc123&quot;; String s2 = &quot;abc&quot;; String s3 = &quot;abc&quot; + &quot;123&quot;; String s4 = s2 + &quot;123&quot;; String s5 = new String(&quot;abc&quot;); String s6 = s5 + &quot;123&quot;;&#125; class文件所生成的字节码文件和当前源文件一不样呢？当然是不一样。 1234567891011121314public class Demo &#123; String s1 = &quot;abc123&quot;; String s2 = &quot;abc&quot;; String s3 = &quot;abc123&quot;; String s4; String s5; String s6; public Demo() &#123; this.s4 = this.s2 + &quot;123&quot;; this.s5 = new String(&quot;abc&quot;); this.s6 = this.s5 + &quot;123&quot;; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java的jvm（持续更新）]]></title>
    <url>%2F2019%2F11%2F16%2F%E7%AC%AC%E5%8D%81%E5%91%A8%E5%91%A8%E4%BC%9A%E5%88%86%E4%BA%AB%EF%BC%88%E5%8F%AF%E6%81%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[java虚拟机内存模型堆堆是java虚拟机里面管理内存最大的一块，它是我们在所有线程所共享的一个内存。此内存区域的唯一目的就是存放对象实例。也就是说我们所有对象、数组都需要在这个堆内存里面进行空间的申请和保存。这块内存也是我们在垃圾收集里面主要的清理的一个区域。所以说也可以说上面GC堆。从内存回收的角度也会有新生代···可以通过-Xmx和-Xms来控制当前的虚拟机内存的大小，如果说堆内存被占满了，程序没有办法申请空间再去分配对象什么的，会爆出OutOfMemoryError异常。 虚拟机栈虚拟机栈是线程私有的，也是和线程生命周期相同，虚拟机栈里面是描述java方法执行的内存模型，我们每个方法在执行的时候，都会创建栈帧。栈帧里面所进行存储（结构）：局部变量表、操作数栈、动态链接和方法出口。局部变量就是编译期间的基本数据类型的或者是对象的引用（指的是当前对象数据在堆里面的地址）如果虚拟机栈里面内存里面没有办法去申请内存保存更多数据（譬如递归会有栈溢出）。操作数栈和局部变量区一样，操作数栈也是被组织成一个以字长为单位的数组。但是和前者不同的是，它不是通过索引来访问，而是通过标准的栈操作——压栈和出栈—来访问的。动态连接 : 虚拟机运行的时候,运行时常量池会保存大量的符号引用，这些符号引用可以看成是每个方法的间接引用。方法的返回分为两种情况：一种是正常退出，退出后会根据方法的定义来决定是否要传返回值给上层的调用者。一种是异常导致的方法结束，这种情况是不会传返回值给上层的调用方法。不过无论是那种方式的方法结束，在退出当前方法时都会跳转到当前方法被调用的位置。如果方法是正常退出的，则调用者的PC计数器的值就可以作为返回地址；如果是因为异常退出的，则是需要通过异常处理表来确定。这个区域规定了两种异常状态：如果线程请求的栈深度大于虚拟机所允许的深度，则抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，在扩展是无法申请到足够的内存，就会抛出OutOfMemoryError异常。 本地方法栈类似于虚拟机栈，区别是虚拟机栈里面保存的是跟我们java系统里面所运行的方法类提供服务的。而我们本地方法栈是为虚拟机去使用当前的一些本地方法去用的。就是一些Native方法。（并不是特别关心） 方法区类似于堆、它也是线程共享的。主要用于存储当前对于虚拟机加载关于类、常量、静态变量或者是一些即时编译后的数据。如果方法区保存数据到临界值了，无法储存了也会说内存溢出。方法区里面有一个运行常量池（Runtime Constant Pool）。在加载java程序的时候，关于类的一些版本，类里面的一些成员变量、方法、接口、一些描述类的信息都会在这里面。还有存放在编译期间的自变量和符号引用。它有个别命叫Non-Heap（非堆）。当方法区无法满足内存分配需求时，抛出OutOfMemoryError异常。 运行时常量池与在JVM堆分配内存(allocate)相比，直接内存分配（allocateDirect）的访问性能更好，但分配较慢。 直接内存直接内存不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域。但这部分区域也被频繁使用，而且也可能导致OutOfMemoryError异常。在JDK1.4中新加入的NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。与在JVM堆分配内存(allocate)相比，直接内存分配（allocateDirect）的访问性能更好，但分配较慢。 程序计数器占的内存小，执行当前字节码行号的记录器。java在多线程，线程轮流切换到时候。一个cpu执行一条线程的指令。譬如执行12345切换。另一个切换123.我们可以通过程序计数器帮我们实现恢复到之前切换走的位置。是线程私有的，用来看线程自己的一个执行的位置，每个线程都有程序计数器，每个线程都有自己独立的计数器，所有线程之间都是互不影响的。 垃圾回收机制算法垃圾回收机制不定时去堆内存中清理不可达对象。不可达的对象并不会马上就会直接回收， 垃圾收集器在一个Java程序中的执行是自动的，不能强制执行，即使能明确地判断出有一块内存已经无用了，是应该回收的，我们也不能强制垃圾收集器回收该内存块。唯一能做的就是通过调用System.gc 方法来”建议”执行垃圾收集器，但其是否可以执行，什么时候执行却都是不可知的。这也是垃圾收集器的最主要的缺点。 12345678910111213public class Test &#123; public static void main(String[] args) &#123; Test test = new Test(); test = null; System.gc(); // 手动回收垃圾 &#125; @Override protected void finalize() throws Throwable &#123; // gc回收垃圾之前调用 System.out.println(&quot;垃圾回收机制...&quot;); &#125;&#125; finalize方法Java技术使用finalize()方法在垃圾收集器将对象从内存中清除出去前，做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在Object类中定义的，所有的类都继承了它。子类覆盖finalize()方法以整理系统资源或者执行其他清理工作。finalize()方法是在垃圾收集器删除对象之前对这个对象调用的。 判断对象是否存活引用计数法引用计数法就是如果一个对象没有被任何引用指向，则可视之为垃圾。这种方法的缺点就是不能检测到环的存在。首先需要声明，至少主流的Java虚拟机里面都没有选用引用计数算法来管理内存。什么是引用计数算法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加１；当引用失效时，计数器值减１.任何时刻计数器值为０的对象就是不可能再被使用的。那为什么主流的Java虚拟机里面都没有选用这种算法呢？其中最主要的原因是它很难解决对象之间相互循环引用的问题。 搜索根算法搜索算法的基本思路就是通过一系列名为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。可以作为GCRoots的对象包括下面几种：(1). 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。(2). 方法区中的类静态属性引用的对象。(3). 方法区中常量引用的对象。(4). 本地方法栈中JNI(Native方法)引用的对象。 java四种引用类型强引用 类似于 Object obj = new Object(); 创建的，只要强引用在就不回收。软引用SoReference 类实现软引用。在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行 二次回收。弱引用 WeakReference 类实现弱引用。对象只能生存到下一次垃圾收集之前。在垃圾收集器工作时，无论内存 是否足够都会回收掉只被弱引用关联的对象。虚引用PhantomReference 类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的 唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 引用类型 用途 被回收时间 生存时间 强引用 对象的一般状态 从来不会 JVM停止运行时终止 软引用 对象缓存 内存不足 内存不足时停止 弱引用 对象缓存 垃圾回收 GC后停止 虚引用 不知道 不知道 不知道 分代算法这种算法，根据对象的存活周期的不同将内存划分成几块，新生代和老年代，新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。新生代对象朝生夕死,对象数量多，只要重点扫描这个区域，那么就可以大大提高垃圾收集的效率。另外老年代对象存储久，无需经常扫描老年代，避免扫描导致的开销。 堆根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。堆大小 = 新生代 + 老年代。其中，堆的大小可以通过参数 –Xms、-Xmx 来指定。默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2( 该值可以通过参数 –XX:NewRatio来指定 )，即：新生代 ( Young ) = 1/3 的堆空间大小。老年代 ( Old ) = 2/3 的堆空间大小。 新生代新的对象实例被创建的时候通常在Eden空间，发生在Eden空间上的GC称为Minor GC，当在新生代发生一次GC后，会将Eden和其中一个Survivor空间的内存复制到另外一个Survivor中，如果反复几次有对象一直存活，此时内存对象将会被移至老年代。可以看到新生代中Eden占了大部分，而两个Survivor实际上占了很小一部分。这是因为大部分的对象被创建过后很快就会被GC 1、新生代的初始值NewSize默认为1M，最大值需要设置，可以通过参数-XX:NewSize和-XX:MaxNewSize或-Xmn进行设置；2、为老年代与新生代的大小比值，默认为2：1；3、SurvivorRatio为新生代中Eden和Survivor的大小比值，默认为8：1 Edem : from : to = 8 :1 : 1 可以通过参数-XX:SurvivorRatio 来设定 )，即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块Survivor 区域是空闲着的。新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。 老年代新生代每进行一次垃圾收集后，就会给存活的对象“加1岁”，当年龄达到一定数量的时候就会进入老年代（默认是15,可以通过-XX：MaxTenuringThreshold来设置）。另外，比较大的对象也会进入老年代，可以-XX：PretenureSizeThreshold进行设置。如-XX：PretenureSizeThreshold3M，那么大于3M的对象就会直接就进入老年代。因此，老年代中存放的都是一些生命周期较长的对象或者特别大的对象。 垃圾回收机制策略标记清除算法该算法有两个阶段。1.标记阶段：找到所有可访问的对象，做个标记2.清除阶段：遍历堆，把未被标记的对象回收 该算法一般应用于老年代,因为老年代的对象生命周期比较长。 标记清除算法的优点和缺点1.优点 是可以解决循环引用的问题 必要时才回收(内存不足时) 2.缺点： 回收时，应用需要挂起，也就是stop the world。 标记和清除的效率不高，尤其是要扫描的对象比较多的时候 会造成内存碎片(会导致明明有内存空间,但是由于不连续,申请稍微大一些的对象无法做到)。 Full GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。现实的生活中，老年代的人通常会比新生代的人”早死”。堆内存中的老年代(Old)不同于这个，老年代里面的对象几乎个个都是在 Survivor 区域中熬过来的，它们是不会那么容易就 “死掉” 了的。因此，Full GC 发生的次数不会有 Minor GC 那么频繁，并且做一次 Full GC 要比进行一次 Minor GC 的时间更长。 复制算法如果jvm使用了coping算法，一开始就会将可用内存分为两块，from域和to域， 每次只是使用from域，to域则空闲着。当from域内存不够了，开始执行GC操作，这个时候，会把from域存活的对象拷贝到to域,然后直接把from域进行内存清理。 优点:在存活对象不多的情况下，性能高，能解决内存碎片。缺点: 会造成一部分的内存浪费。不过可以根据实际情况，将内存块大小比例适当调整；如果存活对象的数量比较大，或者，对象存活率较高时就要进行较多的复制操作，coping的性能会变得很差。 标记压缩算法标记清除算法和标记压缩算法非常相同，但是标记压缩算法在标记清除算法之上解决内存碎片化。 任意顺序 : 即不考虑原先对象的排列顺序，也不考虑对象之间的引用关系，随意移动对象；线性顺序 : 考虑对象的引用关系，例如a对象引用了b对象，则尽可能将a和b移动到一块；滑动顺序 : 按照对象原来在堆中的顺序滑动到堆的一端。 优点:解决内存碎片问题，缺点压缩阶段，由于移动了可用对象，需要去更新引用。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十周小分享]]></title>
    <url>%2F2019%2F11%2F09%2F%E7%AC%AC%E5%8D%81%E5%91%A8%E5%B0%8F%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[神奇姚老板这能输出什么123456789101112131415161718public class Test &#123;static Test test = new Test(&quot;3&quot;);static&#123;System.out.println(&quot;1&quot;);&#125;&#123;System.out.println(&quot;2&quot;);&#125;Test(String s)&#123;System.out.println(s);&#125;public static void staticFunction()&#123;System.out.println(&quot;4&quot;);&#125;public static void main(String[] args) &#123;staticFunction();&#125;&#125; 答案是 12342314 在分配内存是先静态的。静态之间的顺序自上而下。所以先执行 1static Test test = new Test(&quot;3&quot;); 在这个对象里面，也是先运行构造代码块，然后再是构造函数。所以是2然后3然后再执行 123static&#123; System.out.println(&quot;1&quot;);&#125; 最后才是输出4 总结一下1.静态代码块在类被加载的时候就运行了，而且只运行一次，并且优先于各种代码块以及构造函数。如果一个类中有多个静态代码块，会按照书写顺序依次执行。2.构造代码块在创建对象时被调用，每次创建对象都会调用一次，但是优先于构造函数执行。构造代码块不是优先于构造函数执行，而是依托于构造函数，也就是说，如果你不实例化对象，构造代码块是不会执行的。 2如图我给打成代码 1234567891011121314151617181920import java.io.Serializable;public class DataObject implements Serializable &#123; private static int i = 0; private String word = &quot; &quot;; public void setWord(String word) &#123; this.word = word; &#125; public static void setI(int i) &#123; DataObject.i = i; &#125; public static void main(String[] args) &#123; DataObject object = new DataObject(); object.setWord(&quot;123&quot;); object.setI(2); &#125;&#125; 将此对象序列化为文件，并在另外一个JVM中读取文件，进行反序列化，请问此时读出的DataObject对象中的word值和i的值分别为： 在另一个jvm中反序列化i还是0，要是不换jvm就变成2了，word一直是123。 所以说序列化是对 对象，而非类进行的这个、我还在拓展序列化ing。可以看看 312345678910111213class Base&#123; public Base(String s)&#123; System.out.println(&quot;B&quot;); &#125;&#125;public class Dervied &#123; public Dervied(String s)&#123; System.out.println(&quot;D&quot;); &#125; public static void main(String[] args) &#123; new Dervied(&quot;C&quot;); &#125;&#125; 问输出是什么A.BD B.DB C.C D.编译错误答案是并不能输出。因为要super。譬如这样 1234public Dervied(String s)&#123; super(s); System.out.println(&quot;D&quot;); &#125; 41.short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?2.算出2乘以8等于几最有效率的方法是什么？3.java中会存在内存泄漏吗，举例说明。 第一题第一个有问题，int类型的1不能给short类型的s1就算是空间足够，第二个嘛根据查找的java规范 a+=b 实际上是 (T1) a=(T1)(a+b) 所以 就是short型了 就没错来着 第二题嘛，可以直接移动 12byte number1 = 2;byte res = (byte) (number1 &lt;&lt; 2); 第三题嘛一个超长的解释。泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。 但是，即使这样，Java也还是存在着内存泄漏的情况，1、长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露。 尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是Java中内存泄露的发生场景，通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的，这就是Java中可能出现内存泄露的情况，例如，缓存系统，我们加载了一个对象放在缓存中(例如放在一个全局map对象中)，然后一直不再使用它，这个对象一直被缓存引用，但却不再被使用。检查java中的内存泄露，一定要让程序将各种分支情况都完整执行到程序结束，然后看某个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。 如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。 2、当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露。 51String s = new String(&quot;xyz&quot;); 创建了几个StringObject？A.两个或一个都有可能 B.两个 C.一个 D.三个 共产生了两个2个对象，第一个是字符串常量xyz,存储于常量池中。第二个对象是new String（）时产生的s，存储于堆中。 612345678public class NULL &#123; public static void haha()&#123; System.out.println(&quot;haha&quot;); &#125; public static void main(String[] args) &#123; ((NULL)null).haha(); &#125;&#125; 能正常运行吗？！可以，并且成功输出了haha。如果改成实例方法，并不可以。 12345678public class NULL &#123; public void haha()&#123; System.out.println(&quot;haha&quot;); &#125; public static void main(String[] args) &#123; ((NULL)null).haha(); &#125;&#125; Exception in thread “main” java.lang.NullPointerException at NULL.main(NULL.java:6)空指针异常。因为null值可以强制转换为任何java类类型,(String)null也是合法的。但null强制转换后是无效对象，其返回值还是为null，而static方法的调用是和类名绑定的，不借助对象进行访问所以能正确输出。反过来，没有static修饰就只能用对象进行访问，使用null调用对象肯定会报空指针错了。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子类获取父类的父类的属性和方法]]></title>
    <url>%2F2019%2F11%2F01%2Fjava%E5%AD%90%E7%B1%BB%E8%8E%B7%E5%8F%96%E7%88%B6%E7%B1%BB%E7%9A%84%E7%88%B6%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[问题源自于招新培训的时候，我听课时候的灵光一现。如果是中国人继承于人类，但是浙江人又继承于中国人，怎么才能获得父类的父类的方法。我寻思了一下有三种。1.在父类里面建立super.爷类的方法。然后子类重写的同时里面super.也是调用自己父类的方法可以实现。12345678910111213141516171819class Grandfather&#123; String a = &quot;爷爷&quot;;&#125;class Father extends Grandfather&#123; String a = &quot;爸爸&quot;; String getGrandfatherName()&#123; return super.a; &#125;&#125;class Son extends Father&#123; String a = &quot;孙子&quot;; String getGrandfatherName()&#123; return super.getGrandfatherName(); &#125;&#125; 2.利用反射的特性，利用类方法直接获取。这种和子不子类，继承不继承无关。也不能这么说，假设我只是知道我是继承的父类，然后可以知道我父类继承的爷爷类，一直到太爷爷类都可以。类方法取出。 3.可以用虚拟机级别的invokeddynamic实现（基于java1.7版本以及以上才可以）太高深了 以下cv1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * @(#)Text4.java * * * @author * @version 1.00 2016/12/6 */import java.lang.invoke.MethodHandle;import java.lang.invoke.MethodType;import static java.lang.invoke.MethodHandles.lookup; public class Text4 &#123; class GrandFather&#123; void thinking()&#123; System.out.println(&quot;i am grandfather&quot;); &#125; &#125; class Father extends GrandFather&#123; void thinking()&#123; System.out.println(&quot;i am father&quot;); &#125; &#125; class son extends Father&#123; void thinking()&#123; try&#123; MethodType mt = MethodType.methodType(void.class); MethodHandle mh = lookup().findSpecial(GrandFather.class, &quot;thinking&quot;, mt, getClass()); mh.invoke(this); &#125;catch(Throwable e)&#123; &#125; &#125; &#125; public static void main(String[] args)&#123; (new Text4().new son()).thinking(); &#125; &#125; 对上述代码使用生成class字节码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168Classfile /E:/JAVAprojects/noMain/bin/noMain/son.class Last modified 2016-12-6; size 1386 bytes Compiled from &quot;son.java&quot;public class noMain.son extends noMain.Father minor version: 0 major version: 51 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Class #2 // noMain/son #2 = Utf8 noMain/son #3 = Class #4 // noMain/Father #4 = Utf8 noMain/Father #5 = Utf8 &lt;init&gt; #6 = Utf8 ()V #7 = Utf8 Code #8 = Methodref #3.#9 // noMain/Father.&quot;&lt;init&gt;&quot;:()V #9 = NameAndType #5:#6 // &quot;&lt;init&gt;&quot;:()V #10 = Utf8 LineNumberTable #11 = Utf8 LocalVariableTable #12 = Utf8 this #13 = Utf8 LnoMain/son; #14 = Utf8 thinking #15 = Methodref #16.#18 // java/lang/Object.getClass:()Ljava/lang/Class; #16 = Class #17 // java/lang/Object #17 = Utf8 java/lang/Object #18 = NameAndType #19:#20 // getClass:()Ljava/lang/Class; #19 = Utf8 getClass #20 = Utf8 ()Ljava/lang/Class; #21 = Fieldref #22.#24 // java/lang/Void.TYPE:Ljava/lang/Class; #22 = Class #23 // java/lang/Void #23 = Utf8 java/lang/Void #24 = NameAndType #25:#26 // TYPE:Ljava/lang/Class; #25 = Utf8 TYPE #26 = Utf8 Ljava/lang/Class; #27 = Methodref #28.#30 // java/lang/invoke/MethodType.methodType:(Ljava/lang/Class;)Ljava/lang/invoke/MethodType; #28 = Class #29 // java/lang/invoke/MethodType #29 = Utf8 java/lang/invoke/MethodType #30 = NameAndType #31:#32 // methodType:(Ljava/lang/Class;)Ljava/lang/invoke/MethodType; #31 = Utf8 methodType #32 = Utf8 (Ljava/lang/Class;)Ljava/lang/invoke/MethodType; #33 = Methodref #34.#36 // java/lang/invoke/MethodHandles.lookup:()Ljava/lang/invoke/MethodHandles$Lookup; #34 = Class #35 // java/lang/invoke/MethodHandles #35 = Utf8 java/lang/invoke/MethodHandles #36 = NameAndType #37:#38 // lookup:()Ljava/lang/invoke/MethodHandles$Lookup; #37 = Utf8 lookup #38 = Utf8 ()Ljava/lang/invoke/MethodHandles$Lookup; #39 = Class #40 // noMain/GrandFather #40 = Utf8 noMain/GrandFather #41 = String #14 // thinking #42 = Methodref #43.#45 // java/lang/invoke/MethodHandles$Lookup.findSpecial:(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle; #43 = Class #44 // java/lang/invoke/MethodHandles$Lookup #44 = Utf8 java/lang/invoke/MethodHandles$Lookup #45 = NameAndType #46:#47 // findSpecial:(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle; #46 = Utf8 findSpecial #47 = Utf8 (Ljava/lang/Class;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle; #48 = Methodref #49.#51 // java/lang/invoke/MethodHandle.invoke:(LnoMain/son;)V #49 = Class #50 // java/lang/invoke/MethodHandle #50 = Utf8 java/lang/invoke/MethodHandle #51 = NameAndType #52:#53 // invoke:(LnoMain/son;)V #52 = Utf8 invoke #53 = Utf8 (LnoMain/son;)V #54 = Class #55 // java/lang/Throwable #55 = Utf8 java/lang/Throwable #56 = Utf8 a #57 = Utf8 mt #58 = Utf8 Ljava/lang/invoke/MethodType; #59 = Utf8 mh #60 = Utf8 Ljava/lang/invoke/MethodHandle; #61 = Utf8 StackMapTable #62 = Class #63 // java/lang/Class #63 = Utf8 java/lang/Class #64 = Utf8 main #65 = Utf8 ([Ljava/lang/String;)V #66 = Methodref #1.#9 // noMain/son.&quot;&lt;init&gt;&quot;:()V #67 = Methodref #1.#68 // noMain/son.thinking:()V #68 = NameAndType #14:#6 // thinking:()V #69 = Utf8 args #70 = Utf8 [Ljava/lang/String; #71 = Utf8 SourceFile #72 = Utf8 son.java #73 = Utf8 InnerClasses #74 = Utf8 Lookup&#123; public noMain.son(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #8 // Method noMain/Father.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 32: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this LnoMain/son; void thinking(); descriptor: ()V flags: Code: stack=5, locals=4, args_size=1 0: aload_0 1: invokevirtual #15 // Method java/lang/Object.getClass:()Ljava/lang/Class; 4: astore_1 5: getstatic #21 // Field java/lang/Void.TYPE:Ljava/lang/Class; 8: invokestatic #27 // Method java/lang/invoke/MethodType.methodType:(Ljava/lang/Class;)Ljava/lang/invoke/MethodType; 11: astore_2 12: invokestatic #33 // Method java/lang/invoke/MethodHandles.lookup:()Ljava/lang/invoke/MethodHandles$Lookup; 15: ldc #39 // class noMain/GrandFather 17: ldc #41 // String thinking 19: aload_2 20: aload_1 21: invokevirtual #42 // Method java/lang/invoke/MethodHandles$Lookup.findSpecial:(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle; 24: astore_3 25: aload_3 26: aload_0 27: invokevirtual #48 // Method java/lang/invoke/MethodHandle.invoke:(LnoMain/son;)V 30: goto 34 33: astore_2 34: return Exception table: from to target type 5 30 33 Class java/lang/Throwable LineNumberTable: line 36: 0 line 38: 5 line 39: 12 line 40: 15 line 41: 17 line 40: 21 line 39: 24 line 43: 25 line 44: 30 line 47: 34 LocalVariableTable: Start Length Slot Name Signature 0 35 0 this LnoMain/son; 5 30 1 a Ljava/lang/Class; 12 18 2 mt Ljava/lang/invoke/MethodType; 25 5 3 mh Ljava/lang/invoke/MethodHandle; StackMapTable: number_of_entries = 2 frame_type = 255 /* full_frame */ offset_delta = 33 locals = [ class noMain/son, class java/lang/Class ] stack = [ class java/lang/Throwable ] frame_type = 0 /* same */ public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=1, args_size=1 0: new #1 // class noMain/son 3: dup 4: invokespecial #66 // Method &quot;&lt;init&gt;&quot;:()V 7: invokevirtual #67 // Method thinking:()V 10: return LineNumberTable: line 53: 0 line 55: 10 LocalVariableTable: Start Length Slot Name Signature 0 11 0 args [Ljava/lang/String;&#125;SourceFile: &quot;son.java&quot;InnerClasses: public static final #74= #43 of #34; //Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles 没有生成invokedynamic调用，应该是我的jvm配置出错，使得jvm栈帧的模式值调用了出栈的第一个实例使得输出答案为 i am father 虚拟机级别动态分配调用方法代码： 123456789101112131415161718192021222324252627282930313233343536373839/** * @(#)StaticDispatch.java * * * @author * @version 1.00 2016/12/6 */ import java.lang.invoke.*;import java.lang.invoke.CallSite;import java.lang.invoke.ConstantCallSite;import java.lang.invoke.MethodHandle;import java.lang.invoke.MethodHandles;import java.lang.invoke.MethodType;import static java.lang.invoke.MethodHandles.lookup; public class StaticDispatch &#123; static class ClassA&#123; public void println(String s)&#123; System.out.println(s); &#125; &#125; private static MethodHandle getPrintlnMH(Object recevier) throws Throwable&#123; MethodType mt = MethodType.methodType(void.class,String.class); return lookup().findVirtual(recevier.getClass(),&quot;println&quot;,mt).bindTo(recevier); &#125; public static void main(String[] args) throws Throwable&#123; Object ob = System.currentTimeMillis() % 2 == 0 ? System.out : new ClassA(); getPrintlnMH(ob).invokeExact(&quot;invoke println&quot;); &#125; &#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bean的加载方式]]></title>
    <url>%2F2019%2F10%2F29%2FBean%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[没错，这就是姗姗来迟的Bean的加载方式。 通过xml方式加载Bean1.最最淳朴的xml加载一个User类 1234567891011121314151617181920public class User &#123; private int id; private String name; public String getName() &#123; return name; &#125; public void setId(int id) &#123; this.id = id; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getId() &#123; return id; &#125;&#125; spring.xml里面的配置 1234&lt;bean id=&quot;user&quot; class=&quot;com.spring.test.bean.User&quot; &gt; &lt;property name=&quot;name&quot; value=&quot;4399&quot;&gt;&lt;/property&gt; &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 测试代码 1234567private ClassPathXmlApplicationContext context;@org.junit.Test public void text1()&#123; User user = (User)context.getBean(&quot;user&quot;); System.out.println(user); &#125; 2.通过Bean工厂加载Bean一个加载User的Bean工厂 12345678public class UserFactory &#123; public static User careateUser()&#123; User user = new User(); user.setId(2); user.setName(&quot;7k7k&quot;); return user; &#125;&#125; spring.xml里面的配置 1&lt;bean id=&quot;userFactory&quot; class=&quot;com.spring.test.bean.UserFactory&quot; factory-method=&quot;careateUser&quot;&gt;&lt;/bean&gt; 测试代码 1234567private ClassPathXmlApplicationContext context;@org.junit.Test public void text2()&#123; User user = (User)context.getBean(&quot;userFactory&quot;); System.out.println(user); &#125; 通过注解方式加载Bean3.通过在类上添加注解让xml识别是bean组件。@Component只要注解包含@Component均可（衍生类 @Repository @Service @Controller），相当于把这个类直接变成一个Bean组件。UUser类 12345678910111213141516171819202122@Controllerpublic class UUser &#123; private int id = 3; private String name = &quot;3366&quot;; public String getName() &#123; return name; &#125; public void setId(int id) &#123; this.id = id; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getId() &#123; return id; &#125;&#125; 因为这是让bean工厂能够看出来这是一个Bean，所以还要在xml里面进行扫描。Bean的名字默认就是类的名字开头小写，可以在注解后面如@Component(“person”)来自定义名字 1&lt;context:component-scan base-package=&quot;com.spring.test.bean&quot;/&gt; 测试代码 12345@org.junit.Test public void text3()&#123; UUser user = (UUser)context.getBean(&quot;UUser&quot;); System.out.println(user); &#125; 4.完全不通过xml，通过@Configuration标注类，@Bean标注提供Bean方法123456789101112@Configurationpublic class SpringConfig &#123; @Bean(&quot;user&quot;) public User user1()&#123; User user = new User(); user.setName(&quot;43999&quot;); user.setId(4); return user; &#125;&#125; 测试类 1234567@org.junit.Test public void text5()&#123; AnnotationConfigApplicationContext context1 = new AnnotationConfigApplicationContext(SpringConfig.class); User user = (User)context1.getBean(&quot;user&quot;); System.out.println(user); &#125; 5.最最最后一种，我寻思这个dsy根本想不到的。通过@Configuration标注类，然后类里面的@Bean不通过自己生成，而去其他包下@ComponentScan(basePackages = “com.spring.test.bean”)扫描。这里扫描的是我之前的第三个UUser的方式，因为他自己加了注解，自己作为一个Bean 12345@Configuration@ComponentScan(basePackages = &quot;com.spring.test.bean&quot;)public class SpringConfig2 &#123;&#125; 测试代码 12345678@org.junit.Test public void text6()&#123; AnnotationConfigApplicationContext context1 = new AnnotationConfigApplicationContext(SpringConfig2.class); UUser user = (UUser)context1.getBean(&quot;UUser&quot;); System.out.println(user); &#125; 下一篇更新我自己看的ioc的源码分析，估计更新要一年。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java的懒加载]]></title>
    <url>%2F2019%2F10%2F11%2Fjava%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[懒加载FatchType.LAZY也称为延迟加载，是Hibernate3关联关系对象默认的加载方式，所谓懒加载就是当在真正需要数据的时候，才真正执行数据加载操作。简单理解为，只有在使用的时候，才会发出sql语句进行查询。懒加载的有效期是在session打开的情况下，当session关闭后，会报异常。当调用load方法加载对象时，返回代理对象，等到真正用到对象的内容时才发出sql语句。急加载FatchType.EAGER 也成为立即加载，时立即执行sql语句。在session没有关闭的之前，如果访问除id外的其他属性才会发sql语句去查询，我们经常犯的一个错误就是在当前session关闭以后访问由load（）加载的对象的非id属性，此时Hibernate尝试通过当前session发sql查询，但发现session已经关闭，这样就会发出no session的异常 。 cv的，根本不懂。以后用到Hibernate再说吧。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Journey to Chengdu]]></title>
    <url>%2F2019%2F10%2F08%2FJourney-to-Chengdu%2F</url>
    <content type="text"><![CDATA[Journey to Chengdu]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java的自定义注解]]></title>
    <url>%2F2019%2F09%2F21%2Fjava%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[首先注解是什么Java注解又称Java标注，是Java语言5.0版本开始支持加入源代码的特殊语法元数据。为我们在代 码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便的使用这些数据。 Java语言中的类、方法、变量、参数和包等都可以被标注。和Javadoc不同，Java标注可以通过反 射获取注解内容。在编译器生成类文件时，注解可以被嵌入到字节码中。Java虚拟机可以保留注 解内容，在运行时可以获取到注解内容。（看不看一样，知道就是了） 不是自定义的java的内置注解@Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有 该方法时，会报编译错误。@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。 @SuppressWarnings - 指示编译器去忽略注解中声明的警告。 从 Java 7 开始，额外添加了 3 个注解:@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产 生的警告。 @FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。 源码注解 注解只在源码中存在，编译.class文件之后就不存在了编译时注解 在源文件和.class文件中都会存在，eg：@Override运行时注解 在运行阶段起作用，甚至影响程序的运行逻辑，eg：@Autowired 这里是真正的自定义注解定义注解类 123public @interface MyService&#123; //@interface声明注解&#125; 注解的注解 1234@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;) @Retention(RetentionPolicy.RUNTIME) @Inherited @Documented 元注解（注解的注解）@Target作用域 Construtor：构造方法 Field：字段声明 Type：类或接口 Local_Variable：局部变量 Method：方法 Package：包声明 Parameter：参数声明@Retention声明周期 Source：只在源码显示，编译时会丢弃 Class：编译时记录到class中，运行时忽略 Runtime：运行时存在，可以在运行时利用反射读取@Inherited允许子类继承@Documented生成javadoc时，会包含注解 定义注解内容123456789101112@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;) @Retention(RetentionPolicy.RUNTIME) @Inherited @Documented public @interface MyController &#123; // @interface 声明注解 // 注解的成员规则：必须声明无参数无异常 String url(); String email(); // 可以使用default给成员默认值 int age() default 20; // 成员的类型有限定： // 合法的类型包括：基本类型、String、Class、Annotation、Enumeration // 如果注解只有一个成员，则成员必须取名value()，在使用的时候可以忽略成员名和赋值符 (=) 一个小demo1234567891011121314151617@MyController(url = &quot;baidu.com&quot;, email = &quot;123@qq.com&quot;, age = 10) public class TestAnno &#123; @MyController(age = 22) private int age; @MyController(val = &quot;123456&quot;) private String password; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; &#125; 获取注解类 1234567891011121314151617181920212223242526272829303132333435363738public class ParseAnno &#123; public static void main(String[] args) throws Exception &#123; // 解析注解 Class&lt;?&gt; annoClazz = Class.forName(&quot;XXX.TestAnno&quot;); // 判断类 注解是否存在 boolean exist = annoClazz.isAnnotationPresent(MyController.class); if (exist) &#123; // 存在 // 获取注解 MyController classAnno = annoClazz.getAnnotation(MyController.class); // 打印注解值 System.out.println(classAnno.email()); &#125; // 获取类中成员变量的注解 Field[] fields = annoClazz.getDeclaredFields(); // 获取类中所有 的成员变量 for (Field f : fields) &#123; // 判断成员变量，注解是否存在 boolean fieldExist = f.isAnnotationPresent(MyController.class); if (fieldExist) &#123; // 获取注解 MyController fieldAnno = f.getAnnotation(MyController.class); // 输出成员变量注解的值 System.out.println(&quot;age = &quot; + fieldAnno.age()); System.out.println(&quot;val = &quot; + fieldAnno.val()); &#125; &#125; &#125; &#125; 几点回忆得起的有的没得一般都是 运行时候的注解@Override就是个标识注解，没什么用就给你看看，知道这是继承。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java虚拟机的类加载]]></title>
    <url>%2F2019%2F09%2F21%2Fjava%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[虚拟机的类加载机制虚拟机把描述类的数据从Class文件加载到内存，对数据校验，转换解析和初始化形成虚拟机可以直接使用的Java类型。类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验 证、准备、解析、初始化、使用和卸载七个阶段。其中验证、准备和解析三个部分统称为连接。当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始 化三步来实现这个类进行初始化。 加载加载就是虚拟机查找.class，并创建一个java.lang.Class的对象，将类的.class文件中的二进制数据读入内存，放在运行时区域的方法区内。然后在堆中创建 java.lang.Class 对象，用来封装类在方法区的数据结构。 （1）Java虚拟机将.class文件读入内存，并为之创建一个Class对象。 （2）任何类被使用时系统都会为其创建一个且仅有一个Class对象。（3）这个Class对象描述了这个类创建出来的对象的所有信息 链接链接包括验证、准备以及解析三个阶段。（1）验证阶段。主要的目的是确保被加载的类（.class文件的字节流）满足Java虚拟机规范，不 会造成安全错误。 （2）准备阶段。负责为类的静态成员分配内存，并设置默认初始值。 （3）解析阶段。将类的二进制数据中的符号引用替换为直接引用。 说明： 符号引用。即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变 量，一个类的相关信息。直接引用。可以理解为一个内存地址，或者一个偏移量。比如类方法，类变量的直接引用 是指向方法区的指针；而实例方法，实例变量的直接引用则是从实例的头指针开始算起到这个实例变量位置的偏 移量。举个例子，现在调用方法hello()，这个方法的地址是0xaabbccdd，那么hello就是符号引用， 0xaabbccdd就是直接引用。在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地 址或偏移量，也就是直接引用。 初始化初始化，则是为标记为常量值的字段赋值的过程。换句话说，只对static修饰的变量或语句块进行初始 化。如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。 怎么说呢类加载只是一个类的生命周期的一部分。先编译才能有class文件使用后还会有垃圾回收 在自己的项目里新建一个java.lang包，里面新建了一个String类，能代替系统String吗不能，因为根据类加载的双亲委派机制，会将请求转发给父类加载器，父类加载器发现冲 突了String就不会加载了。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习的反射）]]></title>
    <url>%2F2019%2F09%2F20%2Fjava%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%8F%8D%E5%B0%84%EF%BC%88%E7%BB%88%E7%A9%B6%E4%BC%9A%E6%9D%A5%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[首先要知道什么是反射。Java的反射指的就是在程序的运行的时候，对于任何一个的类，这个类的所有的方法和属性都可以知道。同样的对象作为类的实例，也可以对它所有的方法和属性加以调用。这种就叫做反射那么反射有什么用呢在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象； 在运行时判断任意一个类所具有的成员变量和方法； 在运行时调用任意一个对象的方法； java的反射apiClass类：就单纯代表一个类Field类：代表类的成员变量Method类：代表类的方法Constructor类：代表类的构造方法 首先是Class类Class类没有共有的构造方法，在被new或者被类加载器加载的时候，每个.class都有一个相应的Class对象。就是编译的时候的里面的.class文件里面必有一个代表这个类的所有信息的Class对象 java中的Class三种获取方式（这里是全部抄的）利用对象调用getClass()方法获取该对象的Class实例； 使用Class类的静态方法forName()，用类的名字获取一个Class实例 ；运用.class的方式来获取Class实例，对于基本数据类型的封装类，还可以采用.TYPE来获取相对应的 基本数据类型的Class实例； 12345678910111213//方式一 Person person = new Person(); Class&lt;? extends Person&gt; personClazz01 = person.getClass();//方式二 try &#123; Class&lt;?&gt; personClazz02 = Class.forName(&quot;Person&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;//方式三 Class&lt;? extends Person&gt; personClazz03 = Person.class; java的Class里面一些重要的方法public Annotation[] getAnnotations () 获取这个类中所有注解 getClassLoader() 获取加载这个类的类加载器getDeclaredMethods() 获取这个类中的所有方法getReturnType() 获取方法的返回类型getParameterTypes() 获取方法的传入参数类型isAnnotation() 测试这类是否是一个注解类getDeclaredConstructors() 获取所有的构造方法getDeclaredMethod(String name, Class… parameterTypes) 获取指定的构造方法（参 数：参数类型.class）getSuperclass() 获取这个类的父类getInterfaces() 获取这个类实现的所有接口getFields() 获取这个类中所有被public修饰的成员变量getField(String name) 获取指定名字的被public修饰的成员变量 newInstance() 返回此Class所表示的类，通过调用默认的（即无参数）构造函数创建的一个新 实例 如何通过反射获取私有成员的变量和私有方法123456789101112131415161718192021222324252627282930public class Person &#123; private String name = &quot;zhangsan&quot;; private String age;public String getName() &#123; return name; &#125;public void setName(String name) &#123; this.name = name; &#125; &#125; Person person = new Person(); //打印没有改变属性之前的name值 System.out.println(&quot;before：&quot; + getPrivateValue(person, &quot;name&quot;)); person.setName(&quot;lisi&quot;); //打印修改之后的name值 System.out.println(&quot;after：&quot; + getPrivateValue(person, &quot;name&quot;));/** * 通过反射获取私有的成员变量 */ private Object getPrivateValue(Person person, String fieldName) &#123; try &#123; Field field = person.getClass().getDeclaredField(fieldName); // 参数值为true，打开禁用访问控制检查 // setAccessible(true) 并不是将方法的访问权限改成了public，而是取消java的权限控制检查。 field.setAccessible(true); return field.get(person); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; 我有奇怪的想法所有的类就是继承于Object类的所有的类也都是Class类的实例，那么Class自己算是实例吗]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[It's just humiliating love]]></title>
    <url>%2F2019%2F08%2F29%2F%E6%9F%AF%E4%BA%BA%E6%9C%89%E4%BA%86%E7%94%B7%E6%9C%8B%E5%8F%8B%2F</url>
    <content type="text"><![CDATA[It’s just humiliating love]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前序]]></title>
    <url>%2F2019%2F08%2F17%2F%E5%91%90%E5%96%8A%2F</url>
    <content type="text"><![CDATA[这是我的博客的开始我在年青时候也曾经做过许多梦，后来大半忘却了，但自己也并不以为可惜。所谓回忆者，虽说可以使人欢欣，有时也不免使人寂寞，使精神的丝缕还牵着已逝的寂寞的时光，又有什么意味呢，而我偏苦于不能全忘却，这不能全忘的一部分，到现在便成了“金清老贼的博客”的来由。]]></content>
      <tags>
        <tag>寻论</tag>
      </tags>
  </entry>
</search>
