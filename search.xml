<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[子类获取父类的父类的属性和方法]]></title>
    <url>%2F2019%2F11%2F01%2Fjava%E5%AD%90%E7%B1%BB%E8%8E%B7%E5%8F%96%E7%88%B6%E7%B1%BB%E7%9A%84%E7%88%B6%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[子类获取父类的父类的属性和方法问题源自于招新培训的时候，我听课时候的灵光一现。如果是中国人继承于人类，但是浙江人又继承于中国人，怎么才能获得父类的父类的方法。我寻思了一下有三种。1.在父类里面建立super.爷类的方法。然后子类重写的同时里面super.也是调用自己父类的方法可以实现。12345678910111213141516171819class Grandfather&#123; String a = &quot;爷爷&quot;;&#125;class Father extends Grandfather&#123; String a = &quot;爸爸&quot;; String getGrandfatherName()&#123; return super.a; &#125;&#125;class Son extends Father&#123; String a = &quot;孙子&quot;; String getGrandfatherName()&#123; return super.getGrandfatherName(); &#125;&#125; 2.利用反射的特性，利用类方法直接获取。这种和子不子类，继承不继承无关。也不能这么说，假设我只是知道我是继承的父类，然后可以知道我父类继承的爷爷类，一直到太爷爷类都可以。类方法取出。 3.可以用虚拟机级别的invokeddynamic实现（基于java1.7版本以及以上才可以）太高深了 以下cv1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * @(#)Text4.java * * * @author * @version 1.00 2016/12/6 */import java.lang.invoke.MethodHandle;import java.lang.invoke.MethodType;import static java.lang.invoke.MethodHandles.lookup; public class Text4 &#123; class GrandFather&#123; void thinking()&#123; System.out.println(&quot;i am grandfather&quot;); &#125; &#125; class Father extends GrandFather&#123; void thinking()&#123; System.out.println(&quot;i am father&quot;); &#125; &#125; class son extends Father&#123; void thinking()&#123; try&#123; MethodType mt = MethodType.methodType(void.class); MethodHandle mh = lookup().findSpecial(GrandFather.class, &quot;thinking&quot;, mt, getClass()); mh.invoke(this); &#125;catch(Throwable e)&#123; &#125; &#125; &#125; public static void main(String[] args)&#123; (new Text4().new son()).thinking(); &#125; &#125; 对上述代码使用生成class字节码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168Classfile /E:/JAVAprojects/noMain/bin/noMain/son.class Last modified 2016-12-6; size 1386 bytes Compiled from &quot;son.java&quot;public class noMain.son extends noMain.Father minor version: 0 major version: 51 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Class #2 // noMain/son #2 = Utf8 noMain/son #3 = Class #4 // noMain/Father #4 = Utf8 noMain/Father #5 = Utf8 &lt;init&gt; #6 = Utf8 ()V #7 = Utf8 Code #8 = Methodref #3.#9 // noMain/Father.&quot;&lt;init&gt;&quot;:()V #9 = NameAndType #5:#6 // &quot;&lt;init&gt;&quot;:()V #10 = Utf8 LineNumberTable #11 = Utf8 LocalVariableTable #12 = Utf8 this #13 = Utf8 LnoMain/son; #14 = Utf8 thinking #15 = Methodref #16.#18 // java/lang/Object.getClass:()Ljava/lang/Class; #16 = Class #17 // java/lang/Object #17 = Utf8 java/lang/Object #18 = NameAndType #19:#20 // getClass:()Ljava/lang/Class; #19 = Utf8 getClass #20 = Utf8 ()Ljava/lang/Class; #21 = Fieldref #22.#24 // java/lang/Void.TYPE:Ljava/lang/Class; #22 = Class #23 // java/lang/Void #23 = Utf8 java/lang/Void #24 = NameAndType #25:#26 // TYPE:Ljava/lang/Class; #25 = Utf8 TYPE #26 = Utf8 Ljava/lang/Class; #27 = Methodref #28.#30 // java/lang/invoke/MethodType.methodType:(Ljava/lang/Class;)Ljava/lang/invoke/MethodType; #28 = Class #29 // java/lang/invoke/MethodType #29 = Utf8 java/lang/invoke/MethodType #30 = NameAndType #31:#32 // methodType:(Ljava/lang/Class;)Ljava/lang/invoke/MethodType; #31 = Utf8 methodType #32 = Utf8 (Ljava/lang/Class;)Ljava/lang/invoke/MethodType; #33 = Methodref #34.#36 // java/lang/invoke/MethodHandles.lookup:()Ljava/lang/invoke/MethodHandles$Lookup; #34 = Class #35 // java/lang/invoke/MethodHandles #35 = Utf8 java/lang/invoke/MethodHandles #36 = NameAndType #37:#38 // lookup:()Ljava/lang/invoke/MethodHandles$Lookup; #37 = Utf8 lookup #38 = Utf8 ()Ljava/lang/invoke/MethodHandles$Lookup; #39 = Class #40 // noMain/GrandFather #40 = Utf8 noMain/GrandFather #41 = String #14 // thinking #42 = Methodref #43.#45 // java/lang/invoke/MethodHandles$Lookup.findSpecial:(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle; #43 = Class #44 // java/lang/invoke/MethodHandles$Lookup #44 = Utf8 java/lang/invoke/MethodHandles$Lookup #45 = NameAndType #46:#47 // findSpecial:(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle; #46 = Utf8 findSpecial #47 = Utf8 (Ljava/lang/Class;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle; #48 = Methodref #49.#51 // java/lang/invoke/MethodHandle.invoke:(LnoMain/son;)V #49 = Class #50 // java/lang/invoke/MethodHandle #50 = Utf8 java/lang/invoke/MethodHandle #51 = NameAndType #52:#53 // invoke:(LnoMain/son;)V #52 = Utf8 invoke #53 = Utf8 (LnoMain/son;)V #54 = Class #55 // java/lang/Throwable #55 = Utf8 java/lang/Throwable #56 = Utf8 a #57 = Utf8 mt #58 = Utf8 Ljava/lang/invoke/MethodType; #59 = Utf8 mh #60 = Utf8 Ljava/lang/invoke/MethodHandle; #61 = Utf8 StackMapTable #62 = Class #63 // java/lang/Class #63 = Utf8 java/lang/Class #64 = Utf8 main #65 = Utf8 ([Ljava/lang/String;)V #66 = Methodref #1.#9 // noMain/son.&quot;&lt;init&gt;&quot;:()V #67 = Methodref #1.#68 // noMain/son.thinking:()V #68 = NameAndType #14:#6 // thinking:()V #69 = Utf8 args #70 = Utf8 [Ljava/lang/String; #71 = Utf8 SourceFile #72 = Utf8 son.java #73 = Utf8 InnerClasses #74 = Utf8 Lookup&#123; public noMain.son(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #8 // Method noMain/Father.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 32: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this LnoMain/son; void thinking(); descriptor: ()V flags: Code: stack=5, locals=4, args_size=1 0: aload_0 1: invokevirtual #15 // Method java/lang/Object.getClass:()Ljava/lang/Class; 4: astore_1 5: getstatic #21 // Field java/lang/Void.TYPE:Ljava/lang/Class; 8: invokestatic #27 // Method java/lang/invoke/MethodType.methodType:(Ljava/lang/Class;)Ljava/lang/invoke/MethodType; 11: astore_2 12: invokestatic #33 // Method java/lang/invoke/MethodHandles.lookup:()Ljava/lang/invoke/MethodHandles$Lookup; 15: ldc #39 // class noMain/GrandFather 17: ldc #41 // String thinking 19: aload_2 20: aload_1 21: invokevirtual #42 // Method java/lang/invoke/MethodHandles$Lookup.findSpecial:(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle; 24: astore_3 25: aload_3 26: aload_0 27: invokevirtual #48 // Method java/lang/invoke/MethodHandle.invoke:(LnoMain/son;)V 30: goto 34 33: astore_2 34: return Exception table: from to target type 5 30 33 Class java/lang/Throwable LineNumberTable: line 36: 0 line 38: 5 line 39: 12 line 40: 15 line 41: 17 line 40: 21 line 39: 24 line 43: 25 line 44: 30 line 47: 34 LocalVariableTable: Start Length Slot Name Signature 0 35 0 this LnoMain/son; 5 30 1 a Ljava/lang/Class; 12 18 2 mt Ljava/lang/invoke/MethodType; 25 5 3 mh Ljava/lang/invoke/MethodHandle; StackMapTable: number_of_entries = 2 frame_type = 255 /* full_frame */ offset_delta = 33 locals = [ class noMain/son, class java/lang/Class ] stack = [ class java/lang/Throwable ] frame_type = 0 /* same */ public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=1, args_size=1 0: new #1 // class noMain/son 3: dup 4: invokespecial #66 // Method &quot;&lt;init&gt;&quot;:()V 7: invokevirtual #67 // Method thinking:()V 10: return LineNumberTable: line 53: 0 line 55: 10 LocalVariableTable: Start Length Slot Name Signature 0 11 0 args [Ljava/lang/String;&#125;SourceFile: &quot;son.java&quot;InnerClasses: public static final #74= #43 of #34; //Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles 没有生成invokedynamic调用，应该是我的jvm配置出错，使得jvm栈帧的模式值调用了出栈的第一个实例使得输出答案为 i am father 虚拟机级别动态分配调用方法代码： 123456789101112131415161718192021222324252627282930313233343536373839/** * @(#)StaticDispatch.java * * * @author * @version 1.00 2016/12/6 */ import java.lang.invoke.*;import java.lang.invoke.CallSite;import java.lang.invoke.ConstantCallSite;import java.lang.invoke.MethodHandle;import java.lang.invoke.MethodHandles;import java.lang.invoke.MethodType;import static java.lang.invoke.MethodHandles.lookup; public class StaticDispatch &#123; static class ClassA&#123; public void println(String s)&#123; System.out.println(s); &#125; &#125; private static MethodHandle getPrintlnMH(Object recevier) throws Throwable&#123; MethodType mt = MethodType.methodType(void.class,String.class); return lookup().findVirtual(recevier.getClass(),&quot;println&quot;,mt).bindTo(recevier); &#125; public static void main(String[] args) throws Throwable&#123; Object ob = System.currentTimeMillis() % 2 == 0 ? System.out : new ClassA(); getPrintlnMH(ob).invokeExact(&quot;invoke println&quot;); &#125; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Bean的加载方式]]></title>
    <url>%2F2019%2F10%2F29%2FBean%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Bean的加载方式没错，这就是姗姗来迟的Bean的加载方式。 通过xml方式加载Bean1.最最淳朴的xml加载一个User类 1234567891011121314151617181920public class User &#123; private int id; private String name; public String getName() &#123; return name; &#125; public void setId(int id) &#123; this.id = id; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getId() &#123; return id; &#125;&#125; spring.xml里面的配置 1234&lt;bean id=&quot;user&quot; class=&quot;com.spring.test.bean.User&quot; &gt; &lt;property name=&quot;name&quot; value=&quot;4399&quot;&gt;&lt;/property&gt; &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 测试代码 1234567private ClassPathXmlApplicationContext context;@org.junit.Test public void text1()&#123; User user = (User)context.getBean(&quot;user&quot;); System.out.println(user); &#125; 2.通过Bean工厂加载Bean一个加载User的Bean工厂 12345678public class UserFactory &#123; public static User careateUser()&#123; User user = new User(); user.setId(2); user.setName(&quot;7k7k&quot;); return user; &#125;&#125; spring.xml里面的配置 1&lt;bean id=&quot;userFactory&quot; class=&quot;com.spring.test.bean.UserFactory&quot; factory-method=&quot;careateUser&quot;&gt;&lt;/bean&gt; 测试代码 1234567private ClassPathXmlApplicationContext context;@org.junit.Test public void text2()&#123; User user = (User)context.getBean(&quot;userFactory&quot;); System.out.println(user); &#125; 通过注解方式加载Bean3.通过在类上添加注解让xml识别是bean组件。@Component只要注解包含@Component均可（衍生类 @Repository @Service @Controller），相当于把这个类直接变成一个Bean组件。UUser类 12345678910111213141516171819202122@Controllerpublic class UUser &#123; private int id = 3; private String name = &quot;3366&quot;; public String getName() &#123; return name; &#125; public void setId(int id) &#123; this.id = id; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getId() &#123; return id; &#125;&#125; 因为这是让bean工厂能够看出来这是一个Bean，所以还要在xml里面进行扫描。Bean的名字默认就是类的名字开头小写，可以在注解后面如@Component(“person”)来自定义名字 1&lt;context:component-scan base-package=&quot;com.spring.test.bean&quot;/&gt; 测试代码 12345@org.junit.Test public void text3()&#123; UUser user = (UUser)context.getBean(&quot;UUser&quot;); System.out.println(user); &#125; 4.完全不通过xml，通过@Configuration标注类，@Bean标注提供Bean方法123456789101112@Configurationpublic class SpringConfig &#123; @Bean(&quot;user&quot;) public User user1()&#123; User user = new User(); user.setName(&quot;43999&quot;); user.setId(4); return user; &#125;&#125; 测试类 1234567@org.junit.Test public void text5()&#123; AnnotationConfigApplicationContext context1 = new AnnotationConfigApplicationContext(SpringConfig.class); User user = (User)context1.getBean(&quot;user&quot;); System.out.println(user); &#125; 5.最最最后一种，我寻思这个dsy根本想不到的。通过@Configuration标注类，然后类里面的@Bean不通过自己生成，而去其他包下@ComponentScan(basePackages = “com.spring.test.bean”)扫描。这里扫描的是我之前的第三个UUser的方式，因为他自己加了注解，自己作为一个Bean 12345@Configuration@ComponentScan(basePackages = &quot;com.spring.test.bean&quot;)public class SpringConfig2 &#123;&#125; 测试代码 12345678@org.junit.Test public void text6()&#123; AnnotationConfigApplicationContext context1 = new AnnotationConfigApplicationContext(SpringConfig2.class); UUser user = (UUser)context1.getBean(&quot;UUser&quot;); System.out.println(user); &#125; 下一篇更新我自己看的ioc的源码分析，估计更新要一年。]]></content>
  </entry>
  <entry>
    <title><![CDATA[姗姗来迟的ioc]]></title>
    <url>%2F2019%2F10%2F12%2F%E5%A7%97%E5%A7%97%E6%9D%A5%E8%BF%9F%E7%9A%84IIOC%2F</url>
    <content type="text"><![CDATA[这才是java的iocioc之前应该知道ioc能干嘛。ClassPathXmlApplicationContext]]></content>
  </entry>
  <entry>
    <title><![CDATA[java的懒加载]]></title>
    <url>%2F2019%2F10%2F11%2Fjava%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[懒加载（延迟加载）懒加载FatchType.LAZY也称为延迟加载，是Hibernate3关联关系对象默认的加载方式，所谓懒加载就是当在真正需要数据的时候，才真正执行数据加载操作。简单理解为，只有在使用的时候，才会发出sql语句进行查询。懒加载的有效期是在session打开的情况下，当session关闭后，会报异常。当调用load方法加载对象时，返回代理对象，等到真正用到对象的内容时才发出sql语句。急加载FatchType.EAGER 也成为立即加载，时立即执行sql语句。在session没有关闭的之前，如果访问除id外的其他属性才会发sql语句去查询，我们经常犯的一个错误就是在当前session关闭以后访问由load（）加载的对象的非id属性，此时Hibernate尝试通过当前session发sql查询，但发现session已经关闭，这样就会发出no session的异常 。 cv的，根本不懂。以后用到Hibernate再说吧。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Journey to Chengdu]]></title>
    <url>%2F2019%2F10%2F08%2FJourney-to-Chengdu%2F</url>
    <content type="text"><![CDATA[Journey to Chengdu 终于可以写一写一次很勇的出行了。事实上我一早就想去成都了。归结于我自己蜗居在寝室，以致于这才去了。以前和柯人预约过的私奔旅行。原计划于这个暑假初去的。但是因为她回家了，并且我自己也需要留校。这个计划就被鸽了。但是当时说是可以在暑假早点回来去心心念念的成都。但是事实也不过如此。也没什么可惜的事情，该不是的就不该是，自己心中气气就行了，也没什么好再提的。也不至于报复的冲动，也是仅仅局限于冲破学校囚笼的干扰。我终于还是到达了成都。不过和预想的大相径庭。我和一个妹子一起去的。这个妹子是我今年年初的时候在探探上认识的。但是和我一样的憨（或者可能还是我比较憨一点）。在去成都之前面基过两次。第一次发现她是个照片，第二次不过是具体商议行程细节罢了。主要我在意的还是比较好沟通的妹子。比和我一起来重庆的刁钻的沈雨蒙好太多了。不至于所有事情都要迁就。我承认有点莽撞了。不光是才熟知就出去耍也好，也或是借给了妹子很多钱，但凡也是我自愿的事情。若有什么好质疑的，理应没必要，并没有参与我这段行程的人，并没有在此之前接近我，或者与我交流的，并不能说什么不好。是三号出发的，住宿预定的是一个在成都信息工程大学的边上最豪华的宾馆。我们对此并没有什么异议，并且也还算是不是情侣的大床房。至少我和她之间也没有什么异议。因为直到最后都没有做任何出格的事情。要说我有什么介意的，不过是晚上被子被抢罢了。三号下午的火车，到了之后直奔春熙路恰个饭，随后便逛了逛四周，妹子很喜欢化妆，便逛了一段时间的化妆品店。随后便是酒店的登记入住。在晚上都没睡好的我和她都超级困。我选择儿童怀旧游戏。妹子选择睡觉。睡醒之后就去找成都的朋友们聊天了。我实属感觉我被冷落了。妹子说晚上12点的时候回来，结果一直没有回来，我担心他没钱给他转了200。她说要回来的。等到凌晨2：00我困得不行了就睡着了。结果到我早上七点多醒的时候都没有回来。我就每隔30-60分钟打一两个电话过去。内心慌张的我甚至想报警。我不清楚具体发生了什么，我的 第一视角可以理解为晚上打车没打到然后就没后续了。幸亏是下午一点多回来了我这才放下心。第二天这才开始。先是想去网红的宽窄巷子打卡，结果人多劝退。以致于被妹子再去拉去春熙路。妹子从她爸手里敲诈了500，然后一个下午和一个晚上，把钱花光了都在买化妆品。我可以理解化妆品的种类很多很多，有干什么什么的。但是把我拉出来当工具人，我的内心实属不满意。大半夜肚子都饿了，定了一个略贵的兔子外卖。兔子头还是挺好吃的，关键是你要把它当成肉不能当成兔子。我第三天就直接自己跑出来去熊猫基地了，结果我还是上当了。居然只能支持网上购票，我就买了票等到了正午进场。下午回去的时候，妹子拉我去狗狗咖啡厅。其实那个咖啡厅还行，除了价格有点贵以外，我还发现其实咖啡厅里面的狗子，很瘦。除了一两只为了打招牌参加选美的狗子。瘦小的哈士奇也是很勇，跳到桌上吃东西。不然不保持这种饥饿感，又有那只狗会为了吃客人手里一点点的狗狗零食围着桌子转。最后一天也照常睡到了中午，收拾收拾回去了。可能是我这次跟的人没有跟对，至少玩的还是挺枯燥乏味的。不过与人的相处倒是值得长久的纪念。一开始我觉得妹子不错，后来感觉根本就没有把我放心上。到最后回去的公交车上。聊着天。妹子突然说了一句：“我知道你舍不得我。”我这才发现我心理的变化或许我没有怎么和女孩子相处过。如果论时间的话，说不定这才是现实意义上最长的。她夜不归宿的确不对。但是她的价值观的确不把这个当回事。到后来可以理解，但是要批评的还是让人这么担心。我还想到了另外一个东西。我以前说我很注重名声，所以不随便谈恋爱。但是要别人口中提及。某个男的是谈过5次恋爱，善始善终和平分手，以及一个男的虽然只谈过一次，但是却和网友出去开房睡一张床。那个来的好点。这我觉得，其实认识的人都知道。不认识的最好也别忽略。我觉得都不太好。但是一个是煞有其事，另外一个开房不过是内心不纯洁的人奇怪的意淫罢了。熟知的人都知道个人本性，不熟知的我也希望能够理解这么一个人的确实存在。 PS：上文儿童怀旧游戏指的是《洛克王国》]]></content>
      <tags>
        <tag>树洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java的自定义注解]]></title>
    <url>%2F2019%2F09%2F21%2Fjava%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[自定义注解首先注解是什么Java注解又称Java标注，是Java语言5.0版本开始支持加入源代码的特殊语法元数据。为我们在代 码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便的使用这些数据。 Java语言中的类、方法、变量、参数和包等都可以被标注。和Javadoc不同，Java标注可以通过反 射获取注解内容。在编译器生成类文件时，注解可以被嵌入到字节码中。Java虚拟机可以保留注 解内容，在运行时可以获取到注解内容。（看不看一样，知道就是了） 不是自定义的java的内置注解@Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有 该方法时，会报编译错误。@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。 @SuppressWarnings - 指示编译器去忽略注解中声明的警告。 从 Java 7 开始，额外添加了 3 个注解:@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产 生的警告。 @FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。 源码注解 注解只在源码中存在，编译.class文件之后就不存在了编译时注解 在源文件和.class文件中都会存在，eg：@Override运行时注解 在运行阶段起作用，甚至影响程序的运行逻辑，eg：@Autowired 这里是真正的自定义注解定义注解类 123public @interface MyService&#123; //@interface声明注解&#125; 注解的注解 1234@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;) @Retention(RetentionPolicy.RUNTIME) @Inherited @Documented 元注解（注解的注解）@Target作用域 Construtor：构造方法 Field：字段声明 Type：类或接口 Local_Variable：局部变量 Method：方法 Package：包声明 Parameter：参数声明@Retention声明周期 Source：只在源码显示，编译时会丢弃 Class：编译时记录到class中，运行时忽略 Runtime：运行时存在，可以在运行时利用反射读取@Inherited允许子类继承@Documented生成javadoc时，会包含注解 定义注解内容123456789101112@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;) @Retention(RetentionPolicy.RUNTIME) @Inherited @Documented public @interface MyController &#123; // @interface 声明注解 // 注解的成员规则：必须声明无参数无异常 String url(); String email(); // 可以使用default给成员默认值 int age() default 20; // 成员的类型有限定： // 合法的类型包括：基本类型、String、Class、Annotation、Enumeration // 如果注解只有一个成员，则成员必须取名value()，在使用的时候可以忽略成员名和赋值符 (=) 一个小demo1234567891011121314151617@MyController(url = &quot;baidu.com&quot;, email = &quot;123@qq.com&quot;, age = 10) public class TestAnno &#123; @MyController(age = 22) private int age; @MyController(val = &quot;123456&quot;) private String password; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; &#125; 获取注解类 1234567891011121314151617181920212223242526272829303132333435363738public class ParseAnno &#123; public static void main(String[] args) throws Exception &#123; // 解析注解 Class&lt;?&gt; annoClazz = Class.forName(&quot;XXX.TestAnno&quot;); // 判断类 注解是否存在 boolean exist = annoClazz.isAnnotationPresent(MyController.class); if (exist) &#123; // 存在 // 获取注解 MyController classAnno = annoClazz.getAnnotation(MyController.class); // 打印注解值 System.out.println(classAnno.email()); &#125; // 获取类中成员变量的注解 Field[] fields = annoClazz.getDeclaredFields(); // 获取类中所有 的成员变量 for (Field f : fields) &#123; // 判断成员变量，注解是否存在 boolean fieldExist = f.isAnnotationPresent(MyController.class); if (fieldExist) &#123; // 获取注解 MyController fieldAnno = f.getAnnotation(MyController.class); // 输出成员变量注解的值 System.out.println(&quot;age = &quot; + fieldAnno.age()); System.out.println(&quot;val = &quot; + fieldAnno.val()); &#125; &#125; &#125; &#125; 几点回忆得起的有的没得一般都是 运行时候的注解@Override就是个标识注解，没什么用就给你看看，知道这是继承。]]></content>
  </entry>
  <entry>
    <title><![CDATA[java虚拟机的类加载]]></title>
    <url>%2F2019%2F09%2F21%2Fjava%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[Java虚拟机的类加载的过程（这应该是第一篇的才对）虚拟机的类加载机制虚拟机把描述类的数据从Class文件加载到内存，对数据校验，转换解析和初始化形成虚拟机可以直接使用的Java类型。类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验 证、准备、解析、初始化、使用和卸载七个阶段。其中验证、准备和解析三个部分统称为连接。 当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始 化三步来实现这个类进行初始化。 加载加载就是虚拟机查找.class，并创建一个java.lang.Class的对象，将类的.class文件中的二进制数据读入内存，放在运行时区域的方法区内。然后在堆中创建 java.lang.Class 对象，用来封装类在方法区的数据结构。 （1）Java虚拟机将.class文件读入内存，并为之创建一个Class对象。 （2）任何类被使用时系统都会为其创建一个且仅有一个Class对象。（3）这个Class对象描述了这个类创建出来的对象的所有信息 链接链接包括验证、准备以及解析三个阶段。（1）验证阶段。主要的目的是确保被加载的类（.class文件的字节流）满足Java虚拟机规范，不 会造成安全错误。 （2）准备阶段。负责为类的静态成员分配内存，并设置默认初始值。 （3）解析阶段。将类的二进制数据中的符号引用替换为直接引用。 说明： 符号引用。即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变 量，一个类的相关信息。直接引用。可以理解为一个内存地址，或者一个偏移量。比如类方法，类变量的直接引用 是指向方法区的指针；而实例方法，实例变量的直接引用则是从实例的头指针开始算起到这个实例变量位置的偏 移量。举个例子，现在调用方法hello()，这个方法的地址是0xaabbccdd，那么hello就是符号引用， 0xaabbccdd就是直接引用。在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地 址或偏移量，也就是直接引用。 初始化初始化，则是为标记为常量值的字段赋值的过程。换句话说，只对static修饰的变量或语句块进行初始 化。如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。 怎么说呢类加载只是一个类的生命周期的一部分。先编译才能有class文件使用后还会有垃圾回收 在自己的项目里新建一个java.lang包，里面新建了一个String类，能代替系统String吗不能，因为根据类加载的双亲委派机制，会将请求转发给父类加载器，父类加载器发现冲 突了String就不会加载了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[java学习的反射（终究会来的学习记录）]]></title>
    <url>%2F2019%2F09%2F20%2Fjava%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%8F%8D%E5%B0%84%EF%BC%88%E7%BB%88%E7%A9%B6%E4%BC%9A%E6%9D%A5%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[java反射首先要知道什么是反射。Java的反射指的就是在程序的运行的时候，对于任何一个的类，这个类的所有的方法和属性都可以知道。同样的对象作为类的实例，也可以对它所有的方法和属性加以调用。这种就叫做反射那么反射有什么用呢在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象； 在运行时判断任意一个类所具有的成员变量和方法； 在运行时调用任意一个对象的方法； java的反射apiClass类：就单纯代表一个类Field类：代表类的成员变量Method类：代表类的方法Constructor类：代表类的构造方法 首先是Class类Class类没有共有的构造方法，在被new或者被类加载器加载的时候，每个.class都有一个相应的Class对象。就是编译的时候的里面的.class文件里面必有一个代表这个类的所有信息的Class对象 java中的Class三种获取方式（这里是全部抄的）利用对象调用getClass()方法获取该对象的Class实例； 使用Class类的静态方法forName()，用类的名字获取一个Class实例 ；运用.class的方式来获取Class实例，对于基本数据类型的封装类，还可以采用.TYPE来获取相对应的 基本数据类型的Class实例； 12345678910111213//方式一 Person person = new Person(); Class&lt;? extends Person&gt; personClazz01 = person.getClass();//方式二 try &#123; Class&lt;?&gt; personClazz02 = Class.forName(&quot;Person&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;//方式三 Class&lt;? extends Person&gt; personClazz03 = Person.class; java的Class里面一些重要的方法public Annotation[] getAnnotations () 获取这个类中所有注解 getClassLoader() 获取加载这个类的类加载器getDeclaredMethods() 获取这个类中的所有方法getReturnType() 获取方法的返回类型getParameterTypes() 获取方法的传入参数类型isAnnotation() 测试这类是否是一个注解类getDeclaredConstructors() 获取所有的构造方法getDeclaredMethod(String name, Class… parameterTypes) 获取指定的构造方法（参 数：参数类型.class）getSuperclass() 获取这个类的父类getInterfaces() 获取这个类实现的所有接口getFields() 获取这个类中所有被public修饰的成员变量getField(String name) 获取指定名字的被public修饰的成员变量 newInstance() 返回此Class所表示的类，通过调用默认的（即无参数）构造函数创建的一个新 实例 如何通过反射获取私有成员的变量和私有方法123456789101112131415161718192021222324252627282930public class Person &#123; private String name = &quot;zhangsan&quot;; private String age;public String getName() &#123; return name; &#125;public void setName(String name) &#123; this.name = name; &#125; &#125; Person person = new Person(); //打印没有改变属性之前的name值 System.out.println(&quot;before：&quot; + getPrivateValue(person, &quot;name&quot;)); person.setName(&quot;lisi&quot;); //打印修改之后的name值 System.out.println(&quot;after：&quot; + getPrivateValue(person, &quot;name&quot;));/** * 通过反射获取私有的成员变量 */ private Object getPrivateValue(Person person, String fieldName) &#123; try &#123; Field field = person.getClass().getDeclaredField(fieldName); // 参数值为true，打开禁用访问控制检查 // setAccessible(true) 并不是将方法的访问权限改成了public，而是取消java的权限控制检查。 field.setAccessible(true); return field.get(person); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; 我有奇怪的想法所有的类就是继承于Object类的所有的类也都是Class类的实例，那么Class自己算是实例吗]]></content>
  </entry>
  <entry>
    <title><![CDATA[It's just humiliating love]]></title>
    <url>%2F2019%2F08%2F29%2F%E6%9F%AF%E4%BA%BA%E6%9C%89%E4%BA%86%E7%94%B7%E6%9C%8B%E5%8F%8B%2F</url>
    <content type="text"><![CDATA[It’s just humiliating love 我也不太懂是怎么回事。今晚，应该说是昨晚。我无意得知我自己的准女朋友居然有了男朋友。而且大学分地后，她的男朋友居然还是同学的同学。我觉得很离谱但是也没什么好说的。毕竟聊天聊的不多。一个女孩子终究还是会厌倦的。有过很亲密无间的就那种交流也好，也会很贴切的将心比心。而且都还是单身。甚至可以在聊天软件说一些很无聊，毫无意义，很恶心很肉麻的话。单纯就图个口嗨的乐子。我暑假的时候同学聚会，兄弟问我有没有女朋友了。我给予肯定的回答但是并不说我的女朋友是谁。毕竟都是高中同学。不过事实上我最终还是说了。我甚至发自内心的还有一点点小自豪。但是，今晚这波操作着实打了我一个措手不及。我以为原本是板上钉钉的事情，结果是别人板上钉钉的事情。关键是我还被蒙在鼓里，我不知道这是在忌惮我还是觉得我无足轻重。反正我自己也有错，不走心也好，不主动也好，自己技不如人也好我也都承认了也没什么好计较的。我没想通 ，想通了再回来写后续。我这个博客的第二篇就是这么晦气的文章也是服了我自己了。 ##更新了我这寻思的也有道理，一个女孩子只是看聊天打字上这么说，但也不一定是。就好比一个骗子，某个人为了骗钱，可以说尽一切的话，不管是对天发誓也好，不管他发的誓会让他自己以及他的双亲反复死多少回也好，那就真的会发生吗？很明显是不会的。就是说出来的话也是一样。 但是不同的人会有不同的底线。有的人会约束自己永远信守自己说过的话；有的人在网上聊天的时候能把话说的天花乱坠，但是现实见面的话蹦不出几个字来，那他可以在网上混的风生水起，但是现实中却很难骗钱；但是就算是现实的沟通聊天也好，如果真的想要骗钱的话，总还是简单的，毕竟是胆大心细的事情，自己立的誓言也不会有神明去管，这就是为什么会有人说“空口无凭”；就是在技术不进步的年代，就算是签字也不能说明某个契约誓言的真实性有效性，唯有画押，或者在强权的压力下。譬如某个厂家生产了某个奶粉，也知道这是有问题的，很多的宝宝吃了之后出现了类似于呕吐的现象。譬如买了10000瓶的奶粉，2000的宝宝出问题了，真正去法院的有几个孩子家长？譬如30。然后这30个是单打独斗的，很多的没有这个精力一直和某奶粉公司耗下去，也有很多的愿意私了。就算是坚持下去的，也不能胜诉，因为企业是有能力和你打官司，并且能有种种理由。你什么时候买的？喝的时候有没有过期？怎么证明某个宝宝是吃了你家奶粉才有不良反应的？这就一问三不知。但是，如果不是这种法制社会，反而是封建社会（我并不是说法治社会没有封建社会好），这种明眼人一眼就看出来了，并且就算是判决也能让很多人信服也便没有那么多问题了。所以这现在是不存在的。要说爱情的话，我觉得不是不靠谱，也不是说恒久远。我所看过了解的爱情故事，最为忠贞的也许就是杨过和小龙女的爱情故事。在所有的小说也好，网文也好，抑或是真实的故事，我没有见过任何能够比这两位更加难的。虽然是小说，不是真实的事情。但是我永远相信这种爱情是真真切切存在的事情。说爱情不靠谱，不如说是某个人不靠谱，或者是自己就不靠谱。爱情是建立在人与人之间的，只有两个靠谱的人，才能有靠谱的爱情。我相信我是一个我所所谓的靠谱的人，我也一直都很在乎我自己的口碑。现在有些词被用滥了。很多的单身都认为是宁缺毋滥，我觉得没有问题，我以前也有过这么形容我自己。但是我对此介意的是我自己的口碑，而不是另一方能够带给我什么。就类似于我在意的反而是别人在背后的指指点点，说我，前女友要是会踢足球，都能组成两个足球队互相pk了。我觉得这种灰色笑话还是不可取的。其他人也许就是找一个好人罢了。所以我觉得，男女在一起时间这么长，可以一起聊天，很幼稚的qq的火花，可以养的超级大，还有轮船，甚至“深爱之钥”、“空间别墅”。同样的，譬如有段时间忙，可能上班，下班，没几句话说的。甚至异地分居。这就好像某个誓言，也没有人去监督。一个人会不会去遵守呢？我不知道，如果是我的话，可以和女性吃饭也好，出去玩也好。但是逾距的事情不能做就是不能做，所以如果这时候有谁会问我的女人是谁，那还是她。假设按照某些宗教也好，信仰也好。我们可以认为，人是由精神和肉体所组成的。人死了，精神（灵魂）还在，有的上天堂，有的下地狱。我可以把它认为是。灵魂在获得肉体之前，它还是灵魂，和死了一样，可以脱离灵魂存在。并且是没有起点的，可人过程都要经历。那么每个人都是一个灵魂，他必须要经历很多事情。出生，成长，衰老，死亡。同样的，在这过程中，有许许多多的事情要经历，并且每个人都不同。那么什么时候死掉的人最痛苦呢？是懵懂的少年，抑或是很多梦想的青年，上有老下有小的壮年，不能享受四世同堂的老年？我觉得都不是，真正痛苦的是流产的，堕胎的，早夭的灵魂。他们刚刚或者正在和肉体互相打磨，结果又要遁回虚空，继续寻找下一个肉体。因为这个过程都是要经历的罢了。男女的爱情也一样。我第一次是还在搞地下党工作，结果我高估了某个女人的忠贞。既不是死在班主任，也不是死在家长，而是死在了另一个小一届的据说看上去很帅的名字里面有鸢的还甚至据说笑起来和鸢尾花盛开一样美男子。这又应该锅甩给谁呢？结果那个男子过于初中以致于某个女人连备胎都不算，对一方怀有向往之情，却对过往的我怀恨在心又是什么无名业火，可是为什么还要在同学之间骂我呢？你要知道我是很注重名声的人，但是光是爱情萌芽阶段的一面之词也好，在同学心中的造势也好，就算是给人的直观感受也好。唇齿不利的我反而却成了过街老鼠。我以前相信因果，相信物质的等价变换。现在我只相信做婊子立牌坊是正确并且可行的行为。有的人可能认为只是个一举两得的事情，其实这是个一举三得的事情。首先做了婊子能赚钱，其次自己还舒服，最重要的是，别人还以为是贞洁烈女。第二次就不是在襁褓里了，是子宫里。甚至双方都没有确立关系。一个萝莉形的妹子，谁都不想辜负了。我兄弟喜欢了好几年的妹子，纯洁的妹子。就算我是想找170+，符合我审美的，比我小的···但是试问又有几个人能如愿呢？我也不看看我自己是什么东西。既然互相喜欢嘛，也没有阻碍，我认为就是可以开始恋爱的事情，可是中途有一些奇怪的差错。我也不约她出来，她也不约我出来。甚至双方一直都没有正式的关系。时间久了就久了。我很在意的是，为什么有没有和我说。一个人总是会死的。被枪打死，被炮炸死，流血流死，癌症去世，车祸去世，以外电死···太多了。但是同样的，总要知道是怎么死的。我啊，终究还是要谈恋爱的。爱情是依附于等价交换实现的，古往今来，谈恋爱永恒不变的还是门当户对。我不是祥林嫂，不是“我真傻，真的”的复读机。鲁迅先生说 “ 第一次吃螃蟹的人是很令人佩服的，不是勇士，谁敢去吃它呢？螃蟹有人吃，蜘蛛一定也有人吃过，不过不好吃，所以后人就不吃了。像这种人我们当极端感谢。 ”我觉得就像是洋葱，大蒜，榴莲或者是更加恶心的东西也是有人吃的。其中包括某些快手主播。我也一样，无非便是证明了有的能吃，有的不能吃，或者不好吃，或者是反胃，或者让你反复呕吐出胃酸，胆汁。目的便在于，知晓了以后不再吃了罢。]]></content>
      <tags>
        <tag>树洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前序]]></title>
    <url>%2F2019%2F08%2F17%2F%E5%91%90%E5%96%8A%2F</url>
    <content type="text"><![CDATA[这是我的博客的开始我在年青时候也曾经做过许多梦，后来大半忘却了，但自己也并不以为可惜。所谓回忆者，虽说可以使人欢欣，有时也不免使人寂寞，使精神的丝缕还牵着已逝的寂寞的时光，又有什么意味呢，而我偏苦于不能全忘却，这不能全忘的一部分，到现在便成了“金清老贼的博客”的来由。]]></content>
  </entry>
</search>
